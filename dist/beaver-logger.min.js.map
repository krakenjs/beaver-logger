{"version":3,"sources":["webpack://beaver/webpack/universalModuleDefinition","webpack://beaver/webpack/bootstrap","webpack://beaver/./node_modules/@babel/runtime/helpers/esm/extends.js","webpack://beaver/./node_modules/@krakenjs/zalgo-promise/src/utils.js","webpack://beaver/./node_modules/@krakenjs/zalgo-promise/src/exceptions.js","webpack://beaver/./node_modules/@krakenjs/zalgo-promise/src/flush.js","webpack://beaver/./node_modules/@krakenjs/zalgo-promise/src/promise.js","webpack://beaver/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://beaver/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack://beaver/./node_modules/@krakenjs/cross-domain-utils/src/constants.js","webpack://beaver/./node_modules/@krakenjs/cross-domain-utils/src/utils.js","webpack://beaver/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/util.js","webpack://beaver/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/weakmap.js","webpack://beaver/./node_modules/@krakenjs/belter/src/util.js","webpack://beaver/./node_modules/@krakenjs/cross-domain-safe-weakmap/src/native.js","webpack://beaver/./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","webpack://beaver/./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","webpack://beaver/./node_modules/@babel/runtime/helpers/esm/construct.js","webpack://beaver/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","webpack://beaver/./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","webpack://beaver/./node_modules/@krakenjs/belter/src/dom.js","webpack://beaver/./node_modules/@krakenjs/belter/src/constants.js","webpack://beaver/./node_modules/@krakenjs/belter/src/http.js","webpack://beaver/./src/constants.js","webpack://beaver/./src/config.js","webpack://beaver/./src/util.js","webpack://beaver/./src/http.js","webpack://beaver/./src/logger.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","hasOwnProperty","p","s","_extends","assign","target","arguments","length","source","apply","isPromise","item","Promise","window","Window","constructor","toString","then","err","flushPromise","dispatchedErrors","possiblyUnhandledPromiseHandlers","activeCount","flushActive","promise","resolve","startActive","endActive","ZalgoPromise","handler","_this","resolved","rejected","errorHandled","error","handlers","dispatching","stack","result","isAsync","res","reject","_proto","prototype","Error","dispatch","_this2","setTimeout","indexOf","push","j","dispatchPossiblyUnhandledError","asyncReject","chain","firstPromise","secondPromise","_handlers$i","onSuccess","onError","promiseResult","catch","undefined","finally","onFinally","try","timeout","time","_this3","clearTimeout","toPromise","TypeError","lazy","all","promises","count","results","slice","prom","hash","awaitPromises","_loop","map","items","method","onPossiblyUnhandledException","cancel","splice","context","args","delay","flush","_setPrototypeOf","setPrototypeOf","__proto__","_inheritsLoose","subClass","superClass","IE_WIN_ACCESS_ERROR","getActualProtocol","win","location","protocol","getProtocol","mockDomain","split","isAboutProtocol","canReadFromWindow","getActualDomain","PROTOCOL","parent","getParent","host","getDomain","domain","isSameDomain","desc","getOwnPropertyDescriptor","isMockProtocol","isActuallySameDomain","iframeWindows","iframeFrames","isWindowClosed","allowMock","closed","message","mockclosed","top","iframeIndex","collection","safeIndexOf","frame","contentWindow","parentNode","doc","ownerDocument","documentElement","contains","isFrameWindowClosed","isWindow","obj","__cross_domain_utils_window_check__","objectIDs","CrossDomainSafeWeakMap","weakmap","keys","values","Math","random","WeakMap","freeze","testWeakMap","testKey","set","hasNativeWeakMap","_cleanupClosedWindows","delete","isSafeToReadWrite","entry","writable","index","has","getOrSet","_getPrototypeOf","getPrototypeOf","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","e","_construct","Parent","Class","isNativeReflectConstruct","a","instance","Function","_wrapNativeSuper","_cache","Map","Wrapper","configurable","getFunctionName","fn","__name__","displayName","setFunctionName","uniqueID","chars","replace","charAt","floor","str","btoa","encodeURIComponent","p1","String","fromCharCode","parseInt","Buffer","from","base64encode","toISOString","toLowerCase","serializeArgs","JSON","stringify","Array","subkey","val","uid","getObjectID","element","passed","Element","nodeType","style","_","isElement","getEmptyObject","memoizeGlobalIndex","memoizeGlobalIndexValidFrom","memoize","options","simpleCache","thisCache","_options$thisNamespac","thisNamespace","cacheTime","memoizeIndex","memoizedFunction","_len","_key","cache","cacheKey","_unused","cacheResult","now","reset","noop","objFilter","filter","Boolean","clear","_ExtendableError","ExtendableError","_Error","_this6","captureStackTrace","isDocumentReady","document","body","readyState","isDocumentInteractive","isBrowser","interval","setInterval","clearInterval","currentScript","getCurrentScript","getStackTrace","stackDetails","exec","scriptLocation","_i22","_Array$prototype$slic2","getElementsByTagName","reverse","script","src","inferCurrentScript","currentUID","getAttribute","ATTRIBUTES","hashedString","total","charCodeAt","abs","strHashStr","dataset","setAttribute","headerBuilders","LOG_LEVEL","DEBUG","INFO","WARN","ERROR","FILE","AUTO_FLUSH_LEVEL","LOG_LEVEL_PRIORITY","DEFAULT_LOG_LEVEL","canUseSendBeacon","_ref","headers","enableSendBeacon","hasHeaders","navigator","sendBeacon","Blob","_ref2","_ref2$win","url","data","_ref2$useBlob","useBlob","json","blob","type","extendIfDefined","getHTTPTransport","httpWin","_ref$enableSendBeacon","httpWindow","assertSameDomain","beaconResult","_ref$method","_ref$headers","_ref$win","_ref$timeout","normalizedHeaders","_i4","_Object$keys2","_i6","builtHeaders","headerBuilder","_i8","_Object$keys4","xhr","XMLHttpRequest","addEventListener","responseHeaders","rawHeaders","_i2","_rawHeaders$trim$spli2","trim","_line$split","join","parseHeaders","getAllResponseHeaders","status","contentType","isJSON","responseBody","responseText","parse","evt","open","setRequestHeader","ontimeout","send","request","Logger","prefix","metricNamespacePrefix","_ref$logLevel","logLevel","_ref$transport","transport","_ref$flushInterval","flushInterval","events","tracking","metrics","payloadBuilders","metaBuilders","trackingBuilders","metricDimensionBuilders","print","level","event","payload","console","log","warning","immediateFlush","meta","builder","localPromise","logger","logPayload","timestamp","enqueue","addBuilder","builders","metric","metricPayload","metricNamespace","dimensions","_i10","loop","safeInterval","debug","info","warn","track","trackingPayload","metricCounter","_metricPayload$value","namespace","metricEventName","metricValue","metricType","metricGauge","metricHistogram","addPayloadBuilder","addMetaBuilder","addMetricDimensionBuilder","addTrackingBuilder","addHeaderBuilder","setTransport","newTransport","configure","opts","__buffer__"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,SAAU,GAAIH,GACK,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,IARnB,CASoB,oBAATK,KAAuBA,KAAOC,MAAO,WAChD,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUR,QAGnC,IAAIC,EAASK,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHV,QAAS,IAUV,OANAW,EAAQH,GAAUI,KAAKX,EAAOD,QAASC,EAAQA,EAAOD,QAASO,GAG/DN,EAAOS,GAAI,EAGJT,EAAOD,QA0Df,OArDAO,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASf,EAASgB,EAAMC,GAC3CV,EAAoBW,EAAElB,EAASgB,IAClCG,OAAOC,eAAepB,EAASgB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASvB,GACX,oBAAXwB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAepB,EAASwB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAepB,EAAS,aAAc,CAAE0B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASjC,GAChC,IAAIgB,EAAShB,GAAUA,EAAO4B,WAC7B,WAAwB,OAAO5B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAM,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,MAAOjB,GAAiBkB,eAAezB,KAAKuB,EAAQC,IAGzG7B,EAAoB+B,EAAI,GAIjB/B,EAAoBA,EAAoBgC,EAAI,G,+BClFtC,SAASC,IAetB,OAdAA,EAAWrB,OAAOsB,QAAU,SAAUC,GACpC,IAAK,IAAIjC,EAAI,EAAGA,EAAIkC,UAAUC,OAAQnC,IAAK,CACzC,IAAIoC,EAASF,UAAUlC,GAEvB,IAAK,IAAIuB,KAAOa,GACV1B,IAAiBkB,eAAezB,KAAKiC,EAAQb,KAC/CU,EAAOV,GAAOa,EAAOb,IAK3B,OAAOU,IAGOI,MAAMzC,KAAMsC,WCbvB,SAASI,EAAUC,GACtB,IACI,IAAKA,EACD,OAAO,EAGX,GAAuB,oBAAZC,SAA2BD,aAAgBC,QAClD,OAAO,EAGX,GAAsB,oBAAXC,QAAmD,mBAAlBA,OAAOC,QAAyBH,aAAgBE,OAAOC,OAC/F,OAAO,EAGX,GAAsB,oBAAXD,QAAwD,mBAAvBA,OAAOE,aAA8BJ,aAAgBE,OAAOE,YACpG,OAAO,EAGX,IAAMC,EAAY,GAAIA,SAEtB,GAAIA,EAAU,CACV,IAAMrC,EAAOqC,EAASzC,KAAKoC,GAE3B,GAAa,oBAAThC,GAAuC,oBAATA,GAAuC,uBAATA,EAC5D,OAAO,EAIf,GAAyB,mBAAdgC,EAAKM,KACZ,OAAO,EAEb,MAAOC,GACL,OAAO,EAGX,OAAO,E,oUCjCX,ICCIC,EDDEC,EAAmB,GACnBC,EAA4F,GCD9FC,EAAc,EAGlB,SAASC,IACL,IAAKD,GAAeH,EAAc,CAC9B,IAAMK,EAAUL,EAChBA,EAAe,KACfK,EAAQC,WAIT,SAASC,IACZJ,GAAe,EAGZ,SAASK,IACZL,GAAe,EACfC,ICdG,IAAMK,EAAY,WAgBrB,SAAAA,EAAYC,GAAuF,IAAAC,EAAA,KAQ/F,GAR+F,KAdnGC,cAAQ,OACRC,cAAQ,OACRC,kBAAY,OACZ5C,WAAK,OACL6C,WAAK,OAELC,cAAQ,OAKRC,iBAAW,OACXC,WAAK,EAIDrE,KAAK+D,UAAW,EAChB/D,KAAKgE,UAAW,EAChBhE,KAAKiE,cAAe,EAEpBjE,KAAKmE,SAAW,GAEZN,EAAS,CAET,IAAIS,EACAJ,EACAH,GAAW,EACXC,GAAW,EACXO,GAAU,EAEdb,IAEA,IACIG,GAAQ,SAAAW,GACAD,EACAT,EAAKL,QAAQe,IAEbT,GAAW,EACXO,EAASE,MAGd,SAAAtB,GACKqB,EACAT,EAAKW,OAAOvB,IAEZc,GAAW,EACXE,EAAQhB,MAIlB,MAAOA,GAGL,OAFAS,SACA3D,KAAKyE,OAAOvB,GAIhBS,IAEAY,GAAU,EAENR,EAEA/D,KAAKyD,QAAQa,GACNN,GACPhE,KAAKyE,OAAOP,IAWvB,IAAAQ,EAAAd,EAAAe,UAwXA,OAxXAD,EAEDjB,QAAA,SAAQa,GACJ,GAAItE,KAAK+D,UAAY/D,KAAKgE,SACtB,OAAOhE,KAGX,GAAI0C,EAAU4B,GACV,MAAM,IAAIM,MAAM,gDAOpB,OAJA5E,KAAK+D,UAAW,EAChB/D,KAAKqB,MAAQiD,EACbtE,KAAK6E,WAEE7E,MACV0E,EAEDD,OAAA,SAAOP,GAAiC,IAAAY,EAAA,KACpC,GAAI9E,KAAK+D,UAAY/D,KAAKgE,SACtB,OAAOhE,KAGX,GAAI0C,EAAUwB,GACV,MAAM,IAAIU,MAAM,+CAGpB,IAAKV,EAAO,CAER,IAAMhB,EAAOgB,GAAmC,mBAAnBA,EAAMlB,SAA0BkB,EAAMlB,WAAalC,GAAiBkC,SAASzC,KAAK2D,GAC/GA,EAAQ,IAAIU,MAAM,gDAAiD1B,GAgBvE,OAbAlD,KAAKgE,UAAW,EAChBhE,KAAKkE,MAAQA,EAERlE,KAAKiE,cACNc,YAAW,WACFD,EAAKb,cFnHnB,SAA2Cf,EAAaM,GAE3D,IAAuC,IAAnCJ,EAAiB4B,QAAQ9B,GAA7B,CAIAE,EAAiB6B,KAAK/B,GAEtB6B,YAAW,WAMP,MAAM7B,IACP,GAEH,IAAK,IAAIgC,EAAI,EAAGA,EAAI7B,EAAiCd,OAAQ2C,IAEzD7B,EAAiC6B,GAAGhC,EAAKM,IEiG7B2B,CAA+BjB,EAAOY,KAE3C,GAGP9E,KAAK6E,WAEE7E,MACV0E,EAEDU,YAAA,SAAYlB,GAGR,OAFAlE,KAAKiE,cAAe,EACpBjE,KAAKyE,OAAOP,GACLlE,MACV0E,EAEDG,SAAA,WAEI,IAAqBd,EAAiC/D,KAAjC+D,SAAUC,EAAuBhE,KAAvBgE,SAAUG,EAAanE,KAAbmE,SAEzC,IAFsDnE,KAA9CoE,cAMHL,GAAaC,GAAlB,CAIAhE,KAAKoE,aAAc,EACnBV,IAUA,IARA,IAAM2B,EAAQ,SAAIC,EAAgCC,GAC9C,OAAOD,EAAarC,MAAK,SAAAuB,GACrBe,EAAc9B,QAAQe,MACvB,SAAAtB,GACCqC,EAAcd,OAAOvB,OAIpB9C,EAAI,EAAGA,EAAI+D,EAAS5B,OAAQnC,IAAK,CAEtC,IAAAoF,EAAwCrB,EAAS/D,GAAzCqF,EAASD,EAATC,UAAWC,EAAOF,EAAPE,QAASlC,EAAOgC,EAAPhC,QAExBc,OAAM,EAEV,GAAIP,EAEA,IACIO,EAASmB,EAAYA,EAAUzF,KAAKqB,OAASrB,KAAKqB,MACpD,MAAO6B,GACLM,EAAQiB,OAAOvB,GACf,cAGD,GAAIc,EAAU,CAEjB,IAAK0B,EAAS,CACVlC,EAAQiB,OAAOzE,KAAKkE,OACpB,SAGJ,IACII,EAASoB,EAAQ1F,KAAKkE,OACxB,MAAOhB,GACLM,EAAQiB,OAAOvB,GACf,UAIR,GAAIoB,aAAkBV,IAAiBU,EAAOP,UAAYO,EAAON,UAAW,CACxE,IAAM2B,EAAkCrB,EAEpCqB,EAAc5B,SACdP,EAAQC,QAAQkC,EAActE,OAE9BmC,EAAQiB,OAAOkB,EAAczB,OAGjCyB,EAAc1B,cAAe,OAEtBvB,EAAU4B,GAEbA,aAAkBV,IAAiBU,EAAOP,UAAYO,EAAON,UACzDM,EAAOP,SACPP,EAAQC,QAAQa,EAAOjD,OAEvBmC,EAAQiB,OAAOH,EAAOJ,OAK1BmB,EAAMf,EAAQd,GAKlBA,EAAQC,QAAQa,GAIxBH,EAAS5B,OAAS,EAClBvC,KAAKoE,aAAc,EACnBT,MACHe,EAEDzB,KAAA,SAAWwC,EAA0DC,GAEjE,GAAID,GAAkC,mBAAdA,IAA6BA,EAAUlF,KAC3D,MAAM,IAAIqE,MAAM,wDAGpB,GAAIc,GAA8B,mBAAZA,IAA2BA,EAAQnF,KACrD,MAAM,IAAIqE,MAAM,sDAGpB,IAAMpB,EAAU,IAAII,EAYpB,OAVA5D,KAAKmE,SAASc,KAAK,CACfzB,UACAiC,YACAC,YAGJ1F,KAAKiE,cAAe,EAEpBjE,KAAK6E,WAEErB,GACVkB,EAEDkB,MAAA,SAAYF,GAGR,OAD4C1F,KAAKiD,UAAK4C,EAAWH,IAEpEhB,EAEDoB,QAAA,SAAQC,GAEJ,GAAIA,GAAkC,mBAAdA,IAA6BA,EAAUxF,KAC3D,MAAM,IAAIqE,MAAM,uCAGpB,OAAO5E,KAAKiD,MAAK,SAACqB,GACd,OAAOV,EAAaoC,IAAID,GACnB9C,MAAK,WACF,OAAOqB,QAEhB,SAACpB,GACA,OAAOU,EAAaoC,IAAID,GACnB9C,MAAK,WACF,MAAMC,SAGrBwB,EAEDuB,QAAA,SAAQC,EAAehD,GAAgC,IAAAiD,EAAA,KAEnD,GAAInG,KAAK+D,UAAY/D,KAAKgE,SACtB,OAAOhE,KAGX,IAAMiG,EAAUlB,YAAW,WAEnBoB,EAAKpC,UAAYoC,EAAKnC,UAI1BmC,EAAK1B,OAAOvB,GAAO,IAAI0B,MAAM,2BAA4BsB,EAAI,SAE9DA,GAEH,OAAOlG,KAAKiD,MAAK,SAAAqB,GAEb,OADA8B,aAAaH,GACN3B,MAEdI,EAGD2B,UAAA,WAEI,GAAuB,oBAAZzD,QACP,MAAM,IAAI0D,UAAU,0BAGxB,OAAO1D,QAAQa,QAAQzD,OAC1B0E,EAED6B,KAAA,WAEI,OADAvG,KAAKiE,cAAe,EACbjE,MACV4D,EAEMH,QAAP,SAAqBpC,GAEjB,OAAIA,aAAiBuC,EAEoBvC,EAIrCqB,EAAUrB,GAEH,IAAIuC,GAAa,SAACH,EAASgB,GAAM,OAAKpD,EAAM4B,KAAKQ,EAASgB,OAG9D,IAAIb,GAAeH,QAAQpC,IACrCuC,EAEMa,OAAP,SAAcP,GACV,OAAO,IAAIN,GAAea,OAAOP,IACpCN,EAEMwB,YAAP,SAAmBlB,GACf,OAAO,IAAIN,GAAewB,YAAYlB,IACzCN,EAEM4C,IAAP,SAAsCC,GAElC,IAAMjD,EAAU,IAAII,EAChB8C,EAAQD,EAASlE,OAEfoE,EAAW,GAAkDC,QAEnE,IAAKF,EAED,OADAlD,EAAQC,QAAQkD,GACTnD,EAeX,IAZA,IAAM6B,EAAQ,SAAIjF,EAAYkF,EAAgCC,GAC1D,OAAOD,EAAarC,MAAK,SAAAuB,GACrBmC,EAAQvG,GAAKoE,EAEC,IADdkC,GAAS,IAELlD,EAAQC,QAAQkD,MAErB,SAAAzD,GACCqC,EAAcd,OAAOvB,OAIpB9C,EAAI,EAAGA,EAAIqG,EAASlE,OAAQnC,IAAK,CACtC,IAAMyG,EAAOJ,EAASrG,GAEtB,GAAIyG,aAAgBjD,GAChB,GAAIiD,EAAK9C,SAAU,CACf4C,EAAQvG,GAAKyG,EAAKxF,MAClBqF,GAAS,EACT,eAED,IAAKhE,EAAUmE,GAAO,CACzBF,EAAQvG,GAAKyG,EACbH,GAAS,EACT,SAGJrB,EAAMjF,EAAGwD,EAAaH,QAAQoD,GAAOrD,GAOzC,OAJc,IAAVkD,GACAlD,EAAQC,QAAQkD,GAGbnD,GACVI,EAEMkD,KAAP,SAAwBL,GACpB,IAAMnC,EAAS,GACTyC,EAAgB,GAAGC,EAAA,SAAArF,GAGrB,GAAI8E,EAASzE,eAAeL,GAAM,CAC9B,IAAMN,EAAQoF,EAAS9E,GAEnBe,EAAUrB,GACV0F,EAAc9B,KAAK5D,EAAM4B,MAAK,SAAAuB,GAC1BF,EAAO3C,GAAO6C,MAGlBF,EAAO3C,GAAON,IAT1B,IAAK,IAAMM,KAAO8E,EAAQO,EAAArF,GAc1B,OAAOiC,EAAa4C,IAAIO,GAAe9D,MAAK,kBAAMqB,MACrDV,EAEMqD,IAAP,SAAiBC,EAA2BC,GAExC,OAAOvD,EAAa4C,IAAIU,EAAMD,IAAIE,KACrCvD,EAEMwD,6BAAP,SAAoCvD,GAChC,OFjYD,SAAsCA,GAGzC,OAFAR,EAAiC4B,KAAKpB,GAE/B,CACHwD,OAAM,WACFhE,EAAiCiE,OAAOjE,EAAiC2B,QAAQnB,GAAU,KE4XxFuD,CAA6BvD,IACvCD,EAEMoC,IAAP,SAAuDmB,EAAqEI,EAAcC,GAEtI,GAAIL,GAA4B,mBAAXA,IAA0BA,EAAO5G,KAClD,MAAM,IAAIqE,MAAM,mCAGpB,IAAIN,EAEJZ,IAEA,IACIY,EAAS6C,EAAO1E,MAAM8E,EAASC,GAAQ,IACzC,MAAOtE,GAEL,OADAS,IACOC,EAAaa,OAAOvB,GAQ/B,OALAS,IAGsBC,EAAaH,QAAQa,IAG9CV,EAEM6D,MAAP,SAAaA,GACT,OAAO,IAAI7D,GAAa,SAAAH,GACpBsB,WAAWtB,EAASgE,OAE3B7D,EAEMlB,UAAP,SAAiBrB,GAEb,SAAIA,GAASA,aAAiBuC,IAIvBlB,EAAUrB,IACpBuC,EAEM8D,MAAP,WACI,ODlbElE,EAAUL,EAAeA,GAAgB,ICkbxBS,EDjbvBL,IACOC,EAHJ,IACGA,GCmbLI,EArcoB,GCPV,SAAS+D,EAAgB9G,EAAGoB,GAMzC,OALA0F,EAAkB7G,OAAO8G,gBAAkB,SAAyB/G,EAAGoB,GAErE,OADApB,EAAEgH,UAAY5F,EACPpB,IAGcA,EAAGoB,GCLb,SAAS6F,EAAeC,EAAUC,GAC/CD,EAASpD,UAAY7D,OAAOY,OAAOsG,EAAWrD,WAC9CoD,EAASpD,UAAU5B,YAAcgF,EACjCH,EAAeG,EAAUC,GCFpB,ICSDC,EAAsB,mCAErB,SAASC,EAAkBC,GAChC,YADyD,IAAzBA,MAA4BtF,QACrDsF,EAAIC,SAASC,SAGf,SAASC,EAAYH,GAC1B,QADmD,IAAzBA,MAA4BtF,QAClDsF,EAAII,WAAY,CAClB,IAAMF,EAAWF,EAAII,WAAWC,MAAM,MAAM,GAE5C,GAAIH,EACF,OAAOA,EAIX,OAAOH,EAAkBC,GAOpB,SAASM,EAAgBN,GAC9B,YADuD,IAAzBA,MAA4BtF,QD5BlD,WC6BDyF,EAAYH,GA0Cd,SAASO,EACdP,GAEA,IAGE,OAAO,EACP,MAAOjF,IAIT,OAAO,EAGF,SAASyF,EAAgBR,QAA0B,IAA1BA,MAA6BtF,QAC3D,IAAMuF,EAAWD,EAAIC,SAErB,IAAKA,EACH,MAAM,IAAIxD,MAAM,gCAGlB,IAAMyD,EAAWH,EAAkBC,GAEnC,IAAKE,EACH,MAAM,IAAIzD,MAAM,gCAGlB,GDnGO,UCmGHyD,EACF,MAAUO,UAGZ,GDtGQ,WCsGJP,EAA6B,CAC/B,IAAMQ,EAnEH,SACLV,GAEA,QAF2B,IAA3BA,MAA8BtF,QAEzBsF,EAIL,IACE,GAAIA,EAAIU,QAAUV,EAAIU,SAAWV,EAC/B,OAAOA,EAAIU,OAEb,MAAO3F,KAwDQ4F,CAAUX,GACzB,OAAIU,GAAUH,IAELC,EAAgBE,GAGfD,WAGZ,IAAMG,EAAOX,EAASW,KAEtB,IAAKA,EACH,MAAM,IAAInE,MAAM,4BAGlB,OAAUyD,EAAQ,KAAKU,EAGlB,SAASC,EAAUb,QAA0B,IAA1BA,MAA6BtF,QACrD,IAAMoG,EAASN,EAAgBR,GAE/B,OAAIc,GAAUd,EAAII,YAAwD,IAA1CJ,EAAII,WAAWvD,QD9HxC,SC+HEmD,EAAII,WAGNU,EAqEF,SAASC,EACdf,GAEA,IApDK,SAA8BA,GACnC,IACE,GAAIA,IAAQtF,OACV,OAAO,EAET,MAAOK,IAIT,IACE,IAAMiG,EAAOrI,OAAOsI,yBAAyBjB,EAAK,YAElD,GAAIgB,IAA4B,IAApBA,EAAKnI,WACf,OAAO,EAET,MAAOkC,IAIT,IAEE,GAAIuF,EAAgBN,IAAQO,IAC1B,OAAO,EAET,MAAOxF,IAIT,IAEE,GAlJG,SAAwBiF,GAC7B,YADsD,IAAzBA,MAA4BtF,QDlClD,UCmCAyF,EAAYH,GAiJbkB,CAAelB,IAAQO,IACzB,OAAO,EAET,MAAOxF,IAIT,IAEE,GAAIyF,EAAgBR,KAASQ,EAAgB9F,QAC3C,OAAO,EAET,MAAOK,IAIT,OAAO,EAMFoG,CAAqBnB,GACxB,OAAO,EAGT,IACE,GAAIA,IAAQtF,OACV,OAAO,EAIT,GAAI4F,EAAgBN,IAAQO,IAC1B,OAAO,EAIT,GAAIM,EAAUnG,UAAYmG,EAAUb,GAClC,OAAO,EAET,MAAOjF,IAIT,OAAO,EA6QT,IAAMqG,EAAgB,GAChBC,EAAe,GAEd,SAASC,EACdtB,EACAuB,QAAkB,IAAlBA,OAAqB,GAErB,IACE,GAAIvB,IAAQtF,OACV,OAAO,EAET,MAAOK,GACP,OAAO,EAGT,IACE,IAAKiF,EACH,OAAO,EAET,MAAOjF,GACP,OAAO,EAGT,IACE,GAAIiF,EAAIwB,OACN,OAAO,EAET,MAAOzG,GAGP,OAAIA,GAAOA,EAAI0G,UAAY3B,EAO7B,GAAIyB,GAAaR,EAAaf,GAC5B,IAEE,GAAIA,EAAI0B,WACN,OAAO,EAET,MAAO3G,IAOX,IACE,IAAKiF,EAAIU,SAAWV,EAAI2B,IACtB,OAAO,EAET,MAAO5G,IAeT,IAAM6G,EAnFR,SAAwBC,EAA+BrH,GACrD,IAAK,IAAIvC,EAAI,EAAGA,EAAI4J,EAAWzH,OAAQnC,IACrC,IACE,GAAI4J,EAAW5J,KAAOuC,EACpB,OAAOvC,EAET,MAAO8C,IAKX,OAAQ,EAwEY+G,CAAYV,EAAepB,GAE/C,IAAqB,IAAjB4B,EAAoB,CACtB,IAAMG,EAAQV,EAAaO,GAE3B,GAAIG,GAnHD,SAA6BA,GAClC,IAAKA,EAAMC,cACT,OAAO,EAGT,IAAKD,EAAME,WACT,OAAO,EAGT,IAAMC,EAAMH,EAAMI,cAElB,GAAID,GAAOA,EAAIE,kBAAoBF,EAAIE,gBAAgBC,SAASN,GAAQ,CAGtE,IAFA,IAAIrB,EAASqB,EAENrB,EAAOuB,YAAcvB,EAAOuB,aAAevB,GAChDA,EAASA,EAAOuB,WAIlB,IAAKvB,EAAOE,OAASsB,EAAIE,gBAAgBC,SAAS3B,EAAOE,MACvD,OAAO,EAIX,OAAO,EA2FQ0B,CAAoBP,GAC/B,OAAO,EAIX,OAAO,EA+ZF,SAASQ,EAASC,GACvB,IACE,GAAIA,IAAQ9H,OACV,OAAO,EAET,MAAOK,GACP,GAAIA,GAAOA,EAAI0G,UAAY3B,EACzB,OAAO,EAIX,IAEE,GAA4C,oBAAxCnH,GAAiBkC,SAASzC,KAAKoK,GACjC,OAAO,EAET,MAAOzH,GACP,GAAIA,GAAOA,EAAI0G,UAAY3B,EACzB,OAAO,EAIX,IACE,GAAIpF,OAAOC,QAAU6H,aAAe9H,OAAOC,OACzC,OAAO,EAET,MAAOI,GACP,GAAIA,GAAOA,EAAI0G,UAAY3B,EACzB,OAAO,EAIX,IACE,GAAI0C,GAAOA,EAAI5K,OAAS4K,EACtB,OAAO,EAET,MAAOzH,GACP,GAAIA,GAAOA,EAAI0G,UAAY3B,EACzB,OAAO,EAIX,IACE,GAAI0C,GAAOA,EAAI9B,SAAW8B,EACxB,OAAO,EAET,MAAOzH,GACP,GAAIA,GAAOA,EAAI0G,UAAY3B,EACzB,OAAO,EAIX,IACE,GAAI0C,GAAOA,EAAIb,MAAQa,EACrB,OAAO,EAET,MAAOzH,GACP,GAAIA,GAAOA,EAAI0G,UAAY3B,EACzB,OAAO,EAaX,IACE,GACE0C,GAC4C,uBAA5CA,EAAIC,oCAEJ,OAAO,EAET,MAAO1H,GACP,OAAO,EAGT,IACE,GAAI,gBAAiByH,GAAO,SAAUA,GAAO,aAAcA,EACzD,OAAO,EAET,MAAOzH,IAIT,OAAO,ECtjCF,SAAS+G,EAAeD,EAAgCrH,GAC3D,IAAK,IAAIvC,EAAI,EAAGA,EAAI4J,EAAWzH,OAAQnC,IAEnC,IACI,GAAI4J,EAAW5J,KAAOuC,EAClB,OAAOvC,EAEb,MAAO8C,IAKb,OAAQ,ECPL,ICgHH2H,EDhHSC,EAAsB,WAS/B,SAAAA,IAII,GAJU,KAPdnK,UAAI,OACJoK,aAAO,OAEPC,UAAI,OAEJC,YAAM,EAIFjL,KAAKW,KAAO,cAA8B,IAAhBuK,KAAKC,WAAmB,GAAC,KEhBpD,WAEH,GAAuB,oBAAZC,QACP,OAAO,EAGX,QAA6B,IAAlBtK,OAAOuK,OACd,OAAO,EAGX,IAEI,IAAMC,EAAc,IAAIF,QAClBG,EAAU,GAOhB,OAJAzK,OAAOuK,OAAOE,GAEdD,EAAYE,IAAID,EAJE,mCAMdD,EAAYrK,IAAIsK,GAMtB,MAAOrI,GAEL,OAAO,GFVHuI,GACA,IACIzL,KAAK+K,QAAU,IAAIK,QACrB,MAAOlI,IAKblD,KAAKgL,KAAQ,GACbhL,KAAKiL,OAAS,GACjB,IAAAvG,EAAAoG,EAAAnG,UAkOA,OAlOAD,EAEDgH,sBAAA,WAKI,IAHA,IAAMX,EAAU/K,KAAK+K,QACfC,EAAOhL,KAAKgL,KAET5K,EAAI,EAAGA,EAAI4K,EAAKzI,OAAQnC,IAAK,CAClC,IAAMiB,EAAQ2J,EAAK5K,GAEnB,GAAIsK,EAASrJ,IAAUoI,EAAepI,GAAQ,CAE1C,GAAI0J,EACA,IACIA,EAAQY,OAAOtK,GACjB,MAAO6B,IAKb8H,EAAK1D,OAAOlH,EAAG,GACfJ,KAAKiL,OAAO3D,OAAOlH,EAAG,GAEtBA,GAAK,KAGhBsE,EAEDkH,kBAAA,SAAkBjK,GAEd,OAAI+I,EAAS/I,IAYhB+C,EAED8G,IAAA,SAAI7J,EAASN,GAET,IAAKM,EACD,MAAM,IAAIiD,MAAM,wBAGpB,IAAMmG,EAAU/K,KAAK+K,QAErB,GAAIA,EACA,IACIA,EAAQS,IAAI7J,EAAKN,GACnB,MAAO6B,UACElD,KAAK+K,QAIpB,GAAI/K,KAAK4L,kBAAkBjK,GACvB,IACI,IAAMhB,EAAOX,KAAKW,KACZkL,EAAQlK,EAAIhB,GAWlB,YATIkL,GAASA,EAAM,KAAOlK,EACtBkK,EAAM,GAAKxK,EAEXP,OAAOC,eAAeY,EAAKhB,EAAM,CAC7BU,MAAU,CAAEM,EAAKN,GACjByK,UAAU,KAMpB,MAAO5I,IAKblD,KAAK0L,wBAEL,IAAMV,EAAOhL,KAAKgL,KACZC,EAASjL,KAAKiL,OACdc,EAAQ9B,EAAYe,EAAMrJ,IAEjB,IAAXoK,GACAf,EAAK/F,KAAKtD,GACVsJ,EAAOhG,KAAK5D,IAEZ4J,EAAOc,GAAS1K,GAEvBqD,EAEDzD,IAAA,SAAIU,GAEA,IAAKA,EACD,MAAM,IAAIiD,MAAM,wBAGpB,IAAMmG,EAAU/K,KAAK+K,QAErB,GAAIA,EACA,IACI,GAAIA,EAAQiB,IAAIrK,GACZ,OAAOoJ,EAAQ9J,IAAIU,GAGzB,MAAOuB,UACElD,KAAK+K,QAIpB,GAAI/K,KAAK4L,kBAAkBjK,GACvB,IACI,IAAMkK,EAAQlK,EAAI3B,KAAKW,MAEvB,OAAIkL,GAASA,EAAM,KAAOlK,EACfkK,EAAM,QAGjB,EACF,MAAO3I,IAKblD,KAAK0L,wBAEL,IACMK,EAAQ9B,EADDjK,KAAKgL,KACcrJ,GAEhC,IAAe,IAAXoK,EAIJ,OAAO/L,KAAKiL,OAAOc,IACtBrH,EAEDiH,OAAA,SAAOhK,GAEH,IAAKA,EACD,MAAM,IAAIiD,MAAM,wBAGpB,IAAMmG,EAAU/K,KAAK+K,QAErB,GAAIA,EACA,IACIA,EAAQY,OAAOhK,GACjB,MAAOuB,UACElD,KAAK+K,QAIpB,GAAI/K,KAAK4L,kBAAkBjK,GACvB,IACI,IAAMkK,EAAQlK,EAAI3B,KAAKW,MAEnBkL,GAASA,EAAM,KAAOlK,IACtBkK,EAAM,GAAKA,EAAM,QAAKhG,GAE5B,MAAO3C,IAKblD,KAAK0L,wBAEL,IAAMV,EAAOhL,KAAKgL,KACZe,EAAQ9B,EAAYe,EAAMrJ,IAEjB,IAAXoK,IACAf,EAAK1D,OAAOyE,EAAO,GACnB/L,KAAKiL,OAAO3D,OAAOyE,EAAO,KAEjCrH,EAEDsH,IAAA,SAAIrK,GAEA,IAAKA,EACD,MAAM,IAAIiD,MAAM,wBAGpB,IAAMmG,EAAU/K,KAAK+K,QAErB,GAAIA,EACA,IACI,GAAIA,EAAQiB,IAAIrK,GACZ,OAAO,EAEb,MAAOuB,UACElD,KAAK+K,QAIpB,GAAI/K,KAAK4L,kBAAkBjK,GACvB,IACI,IAAMkK,EAAQlK,EAAI3B,KAAKW,MAEvB,SAAIkL,GAASA,EAAM,KAAOlK,GAK5B,MAAOuB,IAQb,OAHAlD,KAAK0L,yBAGa,IADJzB,EAAYjK,KAAKgL,KAAMrJ,IAExC+C,EAEDuH,SAAA,SAAStK,EAASf,GACd,GAAIZ,KAAKgM,IAAIrK,GAET,OAAO3B,KAAKiB,IAAIU,GAGpB,IAAMN,EAAQT,IAEd,OADAZ,KAAKwL,IAAI7J,EAAKN,GACPA,GACVyJ,EAzP8B,GGPpB,SAASoB,EAAgBrL,GAItC,OAHAqL,EAAkBpL,OAAO8G,eAAiB9G,OAAOqL,eAAiB,SAAyBtL,GACzF,OAAOA,EAAEgH,WAAa/G,OAAOqL,eAAetL,KAEvBA,GCJV,SAASuL,IACtB,GAAuB,oBAAZC,UAA4BA,QAAQC,UAAW,OAAO,EACjE,GAAID,QAAQC,UAAUC,KAAM,OAAO,EACnC,GAAqB,mBAAVC,MAAsB,OAAO,EAExC,IAEE,OADAC,KAAK9H,UAAU3B,SAASzC,KAAK8L,QAAQC,UAAUG,KAAM,IAAI,iBAClD,EACP,MAAOC,GACP,OAAO,GCPI,SAASC,EAAWC,EAAQpF,EAAMqF,GAc/C,OAZEF,EADEG,IACWT,QAAQC,UAER,SAAoBM,EAAQpF,EAAMqF,GAC7C,IAAIE,EAAI,CAAC,MACTA,EAAE9H,KAAKxC,MAAMsK,EAAGvF,GAChB,IACIwF,EAAW,IADGC,SAASrL,KAAKa,MAAMmK,EAAQG,IAG9C,OADIF,GAAOjF,EAAeoF,EAAUH,EAAMlI,WACnCqI,IAIOvK,MAAM,KAAMH,WCZjB,SAAS4K,EAAiBL,GACvC,IAAIM,EAAwB,mBAARC,IAAqB,IAAIA,SAAQvH,EA8BrD,OA5BAqH,EAAmB,SAA0BL,GAC3C,GAAc,OAAVA,ICP0D,IAAzDI,SAASjK,SAASzC,KDOiBsM,GCPR7H,QAAQ,iBDOQ,OAAO6H,EAEvD,GAAqB,mBAAVA,EACT,MAAM,IAAIvG,UAAU,sDAGtB,QAAsB,IAAX6G,EAAwB,CACjC,GAAIA,EAAOnB,IAAIa,GAAQ,OAAOM,EAAOlM,IAAI4L,GAEzCM,EAAO3B,IAAIqB,EAAOQ,GAGpB,SAASA,IACP,OAAOf,EAAUO,EAAOvK,UAAW6J,EAAenM,MAAM+C,aAW1D,OARAsK,EAAQ1I,UAAY7D,OAAOY,OAAOmL,EAAMlI,UAAW,CACjD5B,YAAa,CACX1B,MAAOgM,EACPrM,YAAY,EACZ8K,UAAU,EACVwB,cAAc,KAGX1F,EAAeyF,EAASR,KAGTA,GLGnB,SAASU,EAA6BC,GAC3C,OAAOA,EAAG7M,MAAQ6M,EAAGC,UAAYD,EAAGE,aAAe,YAG9C,SAASC,EAA6BH,EAAO7M,GAClD,WACS6M,EAAG7M,KACV6M,EAAG7M,KAAOA,EACV,MAAOuC,IAKT,OADAsK,EAAGC,SAAWD,EAAGE,YAAc/M,EACxB6M,EAuCF,SAASI,IACd,IAAMC,EAAQ,mBAYd,MAAO,OAVU,aAAaC,QAAQ,MAAM,WAC1C,OAAOD,EAAME,OAAO7C,KAAK8C,MAAM9C,KAAKC,SAAW0C,EAAMtL,YASjC,IAjDjB,SAAsB0L,GAC3B,GAAoB,mBAATC,KACT,OAAOA,KACLC,mBAAmBF,GAAKH,QAAQ,mBAAmB,SAACtN,EAAG4N,GACrD,OAAOC,OAAOC,aAAaC,SAASH,EAAI,SAE1CN,QAAQ,OAAQ,IAGpB,GAAsB,oBAAXU,OACT,OAAOA,OAAOC,KAAKR,EAAK,QAAQjL,SAAS,UAAU8K,QAAQ,OAAQ,IAGrE,MAAM,IAAIlJ,MAAM,sCA8BD8J,EACb,IAAIjC,MAAOkC,cAAc/H,MAAM,GAAI,IAAIkH,QAAQ,IAAK,MAEnDA,QAAQ,gBAAiB,IACzBc,cAyCL,SAASC,EAAiBrH,GACxB,IAEE,OAAOsH,KAAKC,UAAUC,GAAgBpI,MAAMrG,KAAKiH,IAAO,SAACyH,EAAQC,GAI/D,MAAmB,mBAARA,EACF,WA7BR,SAAqBvE,GAG1B,GAFAE,EAAYA,GAAa,IAAIO,EAG3BT,SAEgB,iBAARA,GAAmC,mBAARA,EAEnC,MAAM,IAAI/F,MAAM,kBAGlB,IAAIuK,EAAMtE,EAAU5J,IAAI0J,GAOxB,OALKwE,IACHA,SAAgBxE,EAAG,IAAIiD,IACvB/C,EAAUW,IAAIb,EAAKwE,IAGdA,EAWiBC,CAAYF,GAAI,IAtInC,SAAmBG,GACxB,IAAIC,GAAS,EAEb,KACMD,aAAmBxM,OAAO0M,SAGhB,OAAZF,GACmB,iBAAZA,GACc,IAArBA,EAAQG,UACiB,iBAAlBH,EAAQI,OACkB,iBAA1BJ,EAAQ/E,iBANfgF,GAAS,GAUX,MAAOI,IAIT,OAAOJ,EAwHCK,CAAUT,GACL,GAGFA,KAET,MAAOhM,GACP,MAAM,IAAI0B,MAAM,6DAIb,SAASgL,IAEd,MAAO,GAST,IAOIC,EAAqB,EACrBC,EAA8B,EAE3B,SAASC,EACd5I,EACA6I,QAAwB,IAAxBA,MAVO,IAYP,IAEIC,EACAC,EAHsDC,EAAPH,EAA3CI,qBAAa,IAAAD,GAAQA,EAAQE,EAAcL,EAApB9J,KAK3BoK,EAAeT,EACnBA,GAAsB,EAEtB,IAAMU,EAAmB,WAA0C,QAAAC,EAAAlO,UAAAC,OAAbiF,EAAI,IAAAwH,MAAAwB,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJjJ,EAAIiJ,GAAAnO,UAAAmO,GAQxD,IAAIC,EASAC,EAhBAL,EAAeR,IACjBG,EAAc,KACdC,EAAY,KACZI,EAAeT,EACfA,GAAsB,GAOtBa,EAFEN,GACFF,EAAYA,GAAa,IAAI9E,GACXa,SAASjM,KAAM4P,GAEzBK,EAAcA,GAAe,GAKvC,IACEU,EAAW9B,EAAcrH,GACzB,MAAAoJ,GACA,OAAOzJ,EAAO1E,MAAMzC,KAAMsC,WAG5B,IAAIuO,EAAcH,EAAMC,GAOxB,GALIE,GAAeR,GAAa5D,KAAKqE,MAAQD,EAAY3K,KAAOmK,WACvDK,EAAMC,GACbE,EAAc,MAGZA,EACF,OAAOA,EAAYxP,MAGrB,IAAM6E,EAAOuG,KAAKqE,MACZzP,EAAQ8F,EAAO1E,MAAMzC,KAAMsC,WAIjC,OAFAoO,EAAMC,GAAY,CAAEzK,OAAM7E,SAEnBA,GAWT,OARAkP,EAAiBQ,MAAQ,WACvBd,EAAc,KACdC,EAAY,MAMPvC,EAFW4C,GAIbP,EAAQrP,MAAQ4M,EAAgBpG,IAAO,cAwGvC,SAAS6J,KA+PT,SAASC,EACdtG,EACAuG,QAA8B,IAA9BA,MAAiCC,SAEjC,IAAM7M,EAAS,GAEf,IAAK,IAAM3C,KAAOgJ,EACXA,EAAI3I,eAAeL,IAASuP,EAAOvG,EAAIhJ,GAAMA,KAIlD2C,EAAO3C,GAAOgJ,EAAIhJ,IAGpB,OAAO2C,EAjXTyL,EAAQqB,MAAQ,WACdtB,EAA8BD,GA2T9BE,GApBK,SAAmBpF,GACxB,GAAI7J,OAAOmK,OAET,OAAOnK,OAAOmK,OAAON,GAGvB,IAAMrG,EAAmB,GACzB,IAAK,IAAM3C,KAAOgJ,EACZA,EAAI3I,eAAeL,IAErB2C,EAAOW,KAAK0F,EAAIhJ,IAKpB,OAAO2C,KAgyBF,IOr3BoB+M,EPq3BdC,EAAe,SAAAC,GAC1B,SAAAD,EAAY1H,GAAiB,IAAA4H,EAQ1B,OAPDA,EAAAD,EAAAhR,KAAA,KAAMqJ,IAAQ,MAETjJ,KAAO6Q,EAAKzO,YAAYpC,KACU,mBAA5BiE,MAAM6M,kBACf7M,MAAM6M,kBAAiBD,EAAOA,EAAKzO,aAEnCyO,EAAKnN,MAAQ,IAAIO,MAAMgF,GAASvF,MACjCmN,EACF,OAAA1J,EAAAwJ,EAAAC,GAAAD,EAVyB,CAUzBpE,EAVkCtI,QO5yC9B,SAAS8M,IAEd,OAAOP,QAAQQ,SAASC,OAAiC,aAAxBD,SAASE,WAGrC,SAASC,IAEd,OAAOX,QAAQQ,SAASC,OAAiC,gBAAxBD,SAASE,WA+OrC,SAASE,IACd,MAAyB,oBAAXlP,aAA8CgD,IAApBhD,OAAOuF,SA3NS2H,GAAQ,WAChE,OAAO,IAAInM,GAAa,SAACH,GACvB,GAAIiO,KAAqBI,IACvB,OAAOrO,IAGT,IAAMuO,EAAWC,aAAY,WAC3B,GAAIP,KAAqBI,IAEvB,OADAI,cAAcF,GACPvO,MAER,UAgZoBqE,GAAA,kBAAAuJ,EAAA5O,MAAA,KAAAH,YAAA,OAAA+O,EAASC,GA40BpC,IAAIa,EAEkB,oBAAbR,SAA2BA,SAASQ,cAAgB,KAIhDC,EAAqCrC,GAAQ,WACxD,GAAIoC,EACF,OAAOA,EAKT,GAFAA,EAlCF,WACE,IACE,IAAM9N,EAVH,WACL,IACE,MAAM,IAAIO,MAAM,KAChB,MAAO1B,GACP,OAAOA,EAAImB,OAAS,IAMNgO,GACRC,EAAe,kCAAkCC,KAAKlO,GACtDmO,EAAiBF,GAAgBA,EAAa,GAEpD,IAAKE,EACH,OACD,QAAAC,EAAA,EAAAC,EAGoB1D,GAAgBpI,MAClCrG,KAAKoR,SAASgB,qBAAqB,WACnCC,UAASH,EAAAC,EAAAnQ,OAAAkQ,IAAE,CAFT,IAAMI,EAAMH,EAAAD,GAGf,GAAII,EAAOC,KAAOD,EAAOC,MAAQN,EAC/B,OAAOK,GAGX,MAAO3P,KAgBO6P,GAGd,OAAOZ,EAGT,MAAM,IAAIvN,MAAM,uCAGZoO,EAAapF,IAIqCmC,GAAQ,WAC9D,IAAI8C,EAEJ,IACEA,EAAST,IACT,MAAOlP,GACP,OAAO8P,EAGT,IAAI7D,EAAM0D,EAAOI,aCx0CZ,YD00CL,GAAI9D,GAAsB,iBAARA,EAChB,OAAOA,EAKT,IAFAA,EAAM0D,EAAOI,aAAgBC,mBAEH,iBAAR/D,EAChB,OAAOA,EAGT,GAAI0D,EAAOC,IAAK,CACd,IAEMK,EPj+BH,SAAoBlF,GAGzB,IAFA,IAAInH,EAAO,GAEF1G,EAAI,EAAGA,EAAI6N,EAAI1L,OAAQnC,IAAK,CACnC,IAAIgT,EAAQnF,EAAI7N,GAAGiT,WAAW,GAAKjT,EAE/B6N,EAAI7N,EAAI,KACVgT,GAASnF,EAAI7N,EAAI,GAAGiT,WAAW,IAAMjT,EAAI,IAG3C0G,GAAQuH,OAAOC,aAAa,GAAMpD,KAAKoI,IAAIF,GAAS,IAGtD,OAAOtM,EOo9BgByM,CADAzE,KAAKC,UAAU,CAAE+D,IADbD,EAAjBC,IACmCU,QADlBX,EAAZW,WAObrE,EAAM,OAJagE,EAAavM,MAC9BuM,EAAa5Q,OCt1CY,SD21C3B4M,EAAMvB,IAKR,OAFAiF,EAAOY,aAAgBP,gBAAuB/D,GAEvCA,KEr1CT,IAKMuE,EAAiB,GCzBVC,EAAY,CACvBC,MAAQ,QACRC,KAAO,OACPC,KAAO,OACPC,MAAQ,SAGGnL,GAAW,CACtBoL,KAAM,SCNKC,GAAmB,CAACN,EAAUG,KAAMH,EAAUI,OAE9CG,GAAqB,CAChCP,EAAUI,MACVJ,EAAUG,KACVH,EAAUE,KACVF,EAAUC,OAKCO,GAETR,EAAUG,KCNRM,GAAmB,SAAHC,GAGc,IAFlCC,EAAOD,EAAPC,QACAC,EAAgBF,EAAhBE,iBAEMC,EAAaF,GAAWxT,OAAOkK,KAAKsJ,GAAS/R,OACnD,SACEM,QACAA,OAAO4R,UAAUC,aAChBF,GACDD,GACA1R,OAAO8R,OAeLD,GAAa,SAAHE,GAKkB,IAAAC,EAAAD,EAJhCzM,WAAG,IAAA0M,EAAGhS,OAAMgS,EACZC,EAAGF,EAAHE,IACAC,EAAIH,EAAJG,KAAIC,EAAAJ,EACJK,eAAO,IAAAD,GAAOA,EAEd,IACE,IAAME,EAAOpG,KAAKC,UAAUgG,GAE5B,IAAK5M,EAAIsM,UAAUC,WACjB,MAAM,IAAI9P,MAAM,2BAGlB,GAAIqQ,EAAS,CACX,IAAME,EAAO,IAAIR,KAAK,CAACO,GAAO,CAAEE,KAAM,qBACtC,OAAOjN,EAAIsM,UAAUC,WAAWI,EAAKK,GAGvC,OAAOhN,EAAIsM,UAAUC,WAAWI,EAAKI,GACrC,MAAOxI,GACP,OAAO,IAIL2I,GAAkB,SAAChT,EAAiBG,GACxC,IAAK,IAAMb,KAAOa,EACZA,EAAOR,eAAeL,KACxBU,EAAOV,GAAOa,EAAOb,KCzCpB,SAAS2T,GAAiBC,GAC/B,OAAO,SAAAlB,GAMqC,IAL1CS,EAAGT,EAAHS,IACA3N,EAAMkN,EAANlN,OACAmN,EAAOD,EAAPC,QACAY,EAAIb,EAAJa,KAAIM,EAAAnB,EACJE,wBAAgB,IAAAiB,GAAQA,EAExB,OAAO5R,EAAaoC,KAAI,WACtB,IAAMyP,EAAaF,GAAoB1S,OACjCsF,EAAMe,EAAauM,GhBsMxB,SACLtN,GAEA,IAAKe,EAAaf,GAChB,MAAM,IAAIvD,MAAM,qCAIlB,OAAOuD,EgB7MCuN,CAAiBD,GACjB5S,OACA8S,GAAe,EAMnB,OAJIvB,GAAiB,CAAEE,UAASC,uBAC9BoB,EAAejB,GAAW,CAAEvM,MAAK2M,MAAKC,KAAMG,EAAMD,SAAS,KAGtDU,GJHN,SAAgBtB,GAS4B,IARjDS,EAAGT,EAAHS,IAAGc,EAAAvB,EACHlN,cAAM,IAAAyO,EAAG,MAAKA,EAAAC,EAAAxB,EACdC,eAAO,IAAAuB,EAAG,GAAEA,EACZX,EAAIb,EAAJa,KACAH,EAAIV,EAAJU,KACAnD,EAAIyC,EAAJzC,KAAIkE,EAAAzB,EACJlM,WAAG,IAAA2N,EAAGjT,OAAMiT,EAAAC,EAAA1B,EACZpO,eAAO,IAAA8P,EAAG,EAACA,EAEX,OAAO,IAAInS,GAAa,SAACH,EAASgB,GAChC,GAAKyQ,GAAQH,GAAUG,GAAQtD,GAAUmD,GAAQG,EAC/C,MAAM,IAAItQ,MAAM,sEAKW,IAA7B,IAAMoR,EAAoB,GAAGC,EAAA,EAAAC,EAEXpV,OAAOkK,KAAKsJ,GAAQ2B,EAAAC,EAAA3T,OAAA0T,IAAE,CAAnC,IAAMtU,EAAGuU,EAAAD,GACZD,EAAkBrU,EAAIiN,eAAiB0F,EAAQ3S,GAG7CuT,EACFc,EAvCU,gBAwCRA,EAxCQ,iBAwCmC,oBACpCjB,GAAQnD,KACjBoE,EA1CU,gBA2CRA,EA3CQ,iBA4CR,oDAGJA,EAAgC,OAC9BA,EAAgC,QAAK,mBAAmB,QAAAG,EAAA,EAAAA,EAE9BzC,EAAcnR,OAAA4T,IACH,IADlC,IACGC,GAAeC,EADK3C,EAAcyC,MACHG,EAAA,EAAAC,EAEnBzV,OAAOkK,KAAKoL,GAAaE,EAAAC,EAAAhU,OAAA+T,IAAE,CAAxC,IAAM3U,EAAG4U,EAAAD,GACZN,EAAkBrU,EAAIiN,eAAiBwH,EAAazU,GAIxD,IAAM6U,EAAM,IAAIrO,EAAIsO,eAuDpB,IAAK,IAAM9U,KArDX6U,EAAIE,iBACF,QACA,WACE,IAAMC,EAzDd,SAAsBC,QAAkB,IAAlBA,MAAqB,IACvB,IAAlB,IAAMtS,EAAS,GAAGuS,EAAA,EAAAC,EACCF,EAAWG,OAAOvO,MAAM,MAAKqO,EAAAC,EAAAvU,OAAAsU,IAAE,CAA7C,IACHG,EADaF,EAAAD,GACiBrO,MAAM,KAA7B7G,EAAGqV,EAAA,GAAK/L,EAAM+L,EAAApQ,MAAA,GACrBtC,EAAO3C,EAAIiN,eAAiB3D,EAAOgM,KAAK,KAAKF,OAE/C,OAAOzS,EAmDuB4S,CAAalX,KAAKmX,yBAE1C,IAAKnX,KAAKoX,OACR,OAAO3S,EACL,IAAIG,MAAM,cACMuC,EAAOyH,cAAa,IAAIkG,EAAG,sCAK/C,IAAMuC,EAAcV,EAAgB,gBAC9BW,EACJD,IAC6C,IAA5CA,EAAYrS,QAAQ,qBACkB,IAArCqS,EAAYrS,QAAQ,cACpBuS,EAAevX,KAAKwX,aAExB,IACED,EAAezI,KAAK2I,MAAMF,GAC1B,MAAOrU,GACP,GAAIoU,EACF,OAAO7S,EAAO,IAAIG,MAAM,iBAAiB5E,KAAKwX,aAAY,MAU9D,OAAO/T,EANK,CACV2T,OAAQpX,KAAKoX,OACb9C,QAASqC,EACT/E,KAAM2F,OAKV,GAGFf,EAAIE,iBACF,SACA,SAACgB,GACCjT,EACE,IAAIG,MAAM,cACMuC,EAAOyH,cAAa,IAAIkG,EAAG,YAAY4C,EAAI1U,WAAU,SAIzE,GAGFwT,EAAImB,KAAKxQ,EAAQ2N,GAAK,GAEJkB,EACZA,EAAkBhU,eAAeL,IACnC6U,EAAIoB,iBAAiBjW,EAAKqU,EAAkBrU,IAI5CuT,EACFtD,EAAO9C,KAAKC,UAAUmG,GACbH,IACTnD,EAAO9Q,OAAOkK,KAAK+J,GAChB9N,KAAI,SAACtF,GACJ,OAAUwM,mBAAmBxM,GAAI,KAC/BoT,EAAO5G,mBAAmB4G,EAAKpT,IAAQ,OAG1CsV,KAAK,MAGVT,EAAIvQ,QAAUA,EACduQ,EAAIqB,UAAY,WACdpT,EACE,IAAIG,MAAM,cAAcuC,EAAOyH,cAAa,IAAIkG,EAAG,oBAIvD0B,EAAIsB,KAAKlG,MItHHmG,CAAQ,CAAE5P,MAAK2M,MAAK3N,SAAQmN,UAASY,YACxCjS,KAAK+N,ICsCL,SAASgH,GAAM3D,GAQQ,IAP5BS,EAAGT,EAAHS,IACAmD,EAAM5D,EAAN4D,OACAC,EAAqB7D,EAArB6D,sBAAqBC,EAAA9D,EACrB+D,gBAAQ,IAAAD,EAAGhE,GAAiBgE,EAAAE,EAAAhE,EAC5BiE,iBAAS,IAAAD,EAAG/C,KAAkB+C,EAAAE,EAAAlE,EAC9BmE,qBAAa,IAAAD,EH3Ee,IG2EEA,EAAA/C,EAAAnB,EAC9BE,wBAAgB,IAAAiB,GAAQA,EAEpBiD,EAA0B,GAC1BC,EAA2B,GAC3BC,EAAgC,GAE9BC,EAAkC,GAClCC,EAA+B,GAC/BC,EAAmC,GACnCC,EAA0C,GAC1CrF,EAAiC,GAEvC,SAASsF,EACPC,EACAC,EACAC,GAEA,GAAKpH,KAAgBlP,OAAOuW,SAAYvW,OAAOuW,QAAQC,OAKrDnF,GAAmBlP,QAAQiU,GAAS/E,GAAmBlP,QAAQoT,IADjE,CAMA,IAAM5Q,EAAO,CAAC0R,GAEd1R,EAAKvC,KAAKkU,IAENA,EAAQjV,OAASiV,EAAQG,UAC3B9R,EAAKvC,KAAK,OAAQkU,EAAQjV,OAASiV,EAAQG,SAG7C,IACMzW,OAAOuW,QAAQH,IAAUpW,OAAOuW,QAAQH,GAAOxW,MACjDI,OAAOuW,QAAQH,GAAOxW,MAAMI,OAAOuW,QAAS5R,GACnC3E,OAAOuW,QAAQC,KAAOxW,OAAOuW,QAAQC,IAAI5W,OAClDI,OAAOuW,QAAQC,IAAI5W,MAAMI,OAAOuW,QAAS5R,GAE3C,MAAOtE,MAKX,SAASqW,IACP,OAAO3V,EAAaoC,KAAI,WACtB,GAAK+L,KAAelP,OAAOuF,SAASC,WAAaO,GAASoL,OAIrDyE,EAAOlW,QAAWmW,EAASnW,QAAWoW,EAAQpW,QAAnD,CAIgB,IAAhB,IAAMiX,EAAO,GAAG3C,EAAA,EAAAA,EACMgC,EAAYtW,OAAAsU,IAChCxB,GAAgBmE,GAAMC,EADFZ,EAAYhC,IACF2C,IAGb,IAAnB,IAKIhV,EALE8P,EAAU,GAAG2B,EAAA,EAAAA,EACGvC,EAAcnR,OAAA0T,IAClCZ,GAAgBf,GAASmF,EADL/F,EAAcuC,IACD3B,IAwBnC,OAnBIQ,IACFtQ,EAAM8T,EAAU,CACdnR,OAAQ,OACR2N,MACAR,UACAY,KAAM,CACJuD,SACAe,OACAd,WACAC,WAEFpE,qBACC3O,MAAMoL,IAGXyH,EAAS,GACTC,EAAW,GACXC,EAAU,GAEH/U,EAAaH,QAAQe,GAAKvB,KAAK+N,OAI1C,IdkdA7J,EACAM,EAEIjE,EACAyC,EctdEyB,QdmdO,IAAbD,MAAgB,IA6BTkG,GAxBkB,WACnB1H,GACFG,aAAaH,GAGf,IAAMyT,EAAgBlW,EAAUA,GAAW,IAAII,EAgB/C,OAdAqC,EAAUlB,YAAW,WACnBvB,EAAU,KACVyC,EAAU,KAEVrC,EAAaoC,IAAImB,GAAQlE,MACvB,SAACqB,GACCoV,EAAajW,QAAQa,MAEvB,SAACpB,GACCwW,EAAajV,OAAOvB,QAGvBuE,GAEIiS,IAKJnM,EAhCLpG,Ecld8BoS,GdkfF,uBche5B,SAASF,EACPJ,EACAC,EACAC,GAEA,QAFO,IAAPA,MAAU,KAELpH,IACH,OAAO4H,EAGL1B,IACFiB,EAAWjB,EAAM,IAAIiB,GAMrB,IAHF,IAAMU,EAAmBzX,EAAA,GACpB8O,EAAUkI,GAAQ,CACrBU,UAAWpN,KAAKqE,MAAM9N,aACtBmT,EAAA,EAAAA,EAEoByC,EAAerW,OAAA4T,IACnCd,GAAgBuE,GAAYH,EADRb,EAAezC,IACCyD,IAMtC,OAzCF,SACEX,EACAC,EACAC,GAEAV,EAAOxT,KAAK,CACVgU,QACAC,QACAC,aAGuC,IAArClF,GAAiBjP,QAAQiU,IAC3BvR,IA0BFoS,CAAQb,EAAOC,EAAOU,GACtBZ,EAAMC,EAAOC,EAAOU,GAEbD,EAGT,SAASI,EAAWC,EAAUP,GAE5B,OADAO,EAAS/U,KAAKwU,GACPE,EAwDT,SAASM,EAAOC,GACd,IAAKnI,IACH,OAAO4H,EAGLzB,IACFgC,EAAcC,gBAAqBjC,EAAqB,IAAIgC,EAAcC,iBAGxEpB,EAAwBxW,OAAS,IAAM2X,EAAcE,aACvDF,EAAcE,WAAa,IAC5B,QAAAC,EAAA,EAAAA,EAEqBtB,EAAuBxW,OAAA8X,IAC3ChF,GACE6E,EAAcE,YAAc,IAC5BX,EAHkBV,EAAuBsB,IAGjCH,EAAcE,YAAc,KAYxC,OARApB,EACErF,EAAUC,MAAK,UACLsG,EAAcC,gBACxBD,EAAcE,YAAc,IAG9BzB,EAAQ1T,KAAKiV,GAENP,EAkEL5H,KdgTC,SACL5K,EACAjB,IAIA,SAASoU,IACGvV,YAAW,WACnBoC,IACAmT,MACCpU,GAGLoU,Gc5TEC,CAAa7S,EAAO8Q,GAGA,iBAAX3V,SACTA,OAAO6T,iBAAiB,gBAAgB,WACtC6C,OAGF1W,OAAO6T,iBAAiB,UAAU,WAChC6C,OAGF1W,OAAO6T,iBAAiB,YAAY,WAClC6C,QAIJ,IAAMI,EAAS,CACba,MAlJF,SAAetB,EAAOC,GACpB,OAAOE,EAAI1F,EAAUC,MAAOsF,EAAOC,IAkJnCsB,KA/IF,SAAcvB,EAAOC,GACnB,OAAOE,EAAI1F,EAAUE,KAAMqF,EAAOC,IA+IlCuB,KA5IF,SAAcxB,EAAOC,GACnB,OAAOE,EAAI1F,EAAUG,KAAMoF,EAAOC,IA4IlCjV,MAzIF,SAAegV,EAAOC,GACpB,OAAOE,EAAI1F,EAAUI,MAAOmF,EAAOC,IAyInCwB,MAtIF,SAAexB,GACb,QADoB,IAAPA,MAAU,KAClBpH,IACH,OAAO4H,EAG2C,IAApD,IAAMiB,EAA2B3J,EAAUkI,GAAS7C,EAAA,EAAAA,EAE9BwC,EAAgBvW,OAAA+T,IACpCjB,GAAgBuF,GAAiBnB,EADbX,EAAgBxC,IACKsE,IAM3C,OAHA5B,EAAMrF,EAAUC,MAAO,QAASgH,GAChClC,EAASzT,KAAK2V,GAEPjB,GAyHPM,SACAY,cAxFF,SAAuBX,GAAiD,IAAAY,EACtE,OAAOb,EAAO,CACZE,gBAAiBD,EAAca,UAC/BC,gBAAiBd,EAAchB,MAC/B+B,YAAgC,OAArBH,EAAEZ,EAAc7Y,OAAKyZ,EAAI,EACpCI,WAAY,UACZd,WAAYF,EAAcE,cAmF5Be,YA/EF,SAAqBjB,GACnB,OAAOD,EAAO,CACZE,gBAAiBD,EAAca,UAC/BC,gBAAiBd,EAAchB,MAC/B+B,YAAaf,EAAc7Y,MAC3B6Z,WAAY,QACZd,WAAYF,EAAcE,cA0E5BgB,gBAtEF,SAAyBlB,GACvB,OAAOD,EAAO,CACZE,gBAAiBD,EAAca,UAC/BC,gBAAiBd,EAAchB,MAC/B+B,YAAaf,EAAc7Y,MAC3B6Z,WAAY,YACZd,WAAYF,EAAcE,cAiE5B1S,QACA6R,iBACA8B,kBAjLF,SAA2B5B,GACzB,OAAOM,EAAWnB,EAAiBa,IAiLnC6B,eA9KF,SAAwB7B,GACtB,OAAOM,EAAWlB,EAAcY,IA8KhC8B,0BAvKF,SAAmC9B,GACjC,OAAOM,EAAWhB,EAAyBU,IAuK3C+B,mBA5KF,SAA4B/B,GAC1B,OAAOM,EAAWjB,EAAkBW,IA4KpCgC,iBArKF,SAA0BhC,GACxB,OAAOM,EAAWrG,EAAgB+F,IAqKlCiC,aApEF,SAAsBC,GAEpB,OADArD,EAAYqD,EACLhC,GAmEPiC,UAhEF,SAAmBC,GAyBjB,OAxBIA,EAAK/G,MACPA,EAAM+G,EAAK/G,KAGT+G,EAAK5D,SACPA,EAAS4D,EAAK5D,QAGZ4D,EAAKzD,WACPA,EAAWyD,EAAKzD,UAGdyD,EAAKvD,YACPA,EAAYuD,EAAKvD,WAGfuD,EAAKrD,gBACPA,EAAgBqD,EAAKrD,eAGnBqD,EAAKtH,mBACPA,EAAmBsH,EAAKtH,kBAGnBoF,GA2CPmC,WAAY,CACV,aACE,OAAOrD,GAET,eACE,OAAOC,GAET,cACE,OAAOC,KAQb,OAFA7X,OAAOC,eAAe4Y,EAAQ,aAAc,CAAE7N,UAAU,IAEjD6N","file":"beaver-logger.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"beaver\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"beaver\"] = factory();\n\telse\n\t\troot[\"beaver\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","/* @flow */\n\nexport function isPromise(item : mixed) : boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.Window === 'function' && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.constructor === 'function' && item instanceof window.constructor) {\n            return false;\n        }\n\n        const toString = ({}).toString;\n\n        if (toString) {\n            const name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nconst dispatchedErrors = [];\nconst possiblyUnhandledPromiseHandlers : Array<(mixed, promise? : ZalgoPromise<mixed>) => void> = [];\n\nexport function dispatchPossiblyUnhandledError<T>(err : mixed, promise : ZalgoPromise<T>) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(`${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${ promise.stack }`);\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        // $FlowFixMe\n        possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler : (mixed, promise? : ZalgoPromise<mixed>) => void) : {| cancel : () => void |} {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nlet activeCount = 0;\nlet flushPromise;\n\nfunction flushActive() {\n    if (!activeCount && flushPromise) {\n        const promise = flushPromise;\n        flushPromise = null;\n        promise.resolve();\n    }\n}\n\nexport function startActive() {\n    activeCount += 1;\n}\n\nexport function endActive() {\n    activeCount -= 1;\n    flushActive();\n}\n\nexport function awaitActive(Zalgo : Class<ZalgoPromise<*>>) : ZalgoPromise<void> { // eslint-disable-line no-undef\n    const promise = flushPromise = flushPromise || new Zalgo();\n    flushActive();\n    return promise;\n}\n","/* @flow */\n/* eslint no-use-before-define: off */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { startActive, endActive, awaitActive } from './flush';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean;\n    rejected : boolean;\n    errorHandled : boolean;\n    value : R;\n    error : mixed;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    handlers : Array<{|\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    |}>;\n    dispatching : boolean;\n    stack : string;\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            startActive();\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                endActive();\n                this.reject(err);\n                return;\n            }\n\n            endActive();\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            // $FlowFixMe\n            const err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${ err }`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) : ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n\n    dispatch() {\n\n        const { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        startActive();\n\n        const chain = <T>(firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                secondPromise.resolve(res);\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            const { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                const promiseResult : ZalgoPromise<*> = result;\n\n                if (promiseResult.resolved) {\n                    promise.resolve(promiseResult.value);\n                } else {\n                    promise.reject(promiseResult.error);\n                }\n\n                promiseResult.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    chain(result, promise);\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        endActive();\n    }\n\n    then<X, Y>(onSuccess : void | (result : R) => (ZalgoPromise<X> | Y), onError : void | (error : mixed) => (ZalgoPromise<X> | Y)) : ZalgoPromise<X | Y> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        const promise = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X, Y>(onError : (error : mixed) => ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n        // $FlowFixMe incompatible-call\n        const resultPromise : ZalgoPromise<X | Y> = this.then(undefined, onError);\n        return resultPromise;\n    }\n\n    finally(onFinally : () => mixed) : ZalgoPromise<R> {\n\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        return this.then((result) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        const timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    lazy() : ZalgoPromise<R> {\n        this.errorHandled = true;\n        return this;\n    }\n\n    static resolve<X, Y>(value : ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n\n        if (value instanceof ZalgoPromise) {\n            // $FlowFixMe incompatible-type-arg\n            const result : ZalgoPromise<X | Y> = value;\n            return result;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X : $ReadOnlyArray<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n\n        const promise = new ZalgoPromise();\n        let count = promises.length;\n        // eslint-disable-next-line no-undef, unicorn/prefer-spread\n        const results = ([] : $TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>).slice();\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        const chain = <T>(i : number, firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                results[i] = res;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < promises.length; i++) {\n            const prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            chain(i, ZalgoPromise.resolve(prom), promise);\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O : Object>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n        const result = {};\n        const awaitPromises = [];\n\n        for (const key in promises) {\n            if (promises.hasOwnProperty(key)) {\n                const value = promises[key];\n\n                if (isPromise(value)) {\n                    awaitPromises.push(value.then(res => {\n                        result[key] = res;\n                    }));\n                } else {\n                    result[key] = value;\n                }\n            }\n        }\n\n        return ZalgoPromise.all(awaitPromises).then(() => result);\n    }\n\n    static map<T, X>(items : $ReadOnlyArray<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<$ReadOnlyArray<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => void) : {| cancel : () => void |} {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X, Y, C : mixed, A : $ReadOnlyArray<mixed>>(method : (...args : $ReadOnlyArray<mixed>) => (ZalgoPromise<X> | Y), context? : C, args? : A) : ZalgoPromise<X | Y> {\n\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result : ZalgoPromise<X> | Y;\n\n        startActive();\n\n        try {\n            result = method.apply(context, args || []);\n        } catch (err) {\n            endActive();\n            return ZalgoPromise.reject(err);\n        }\n\n        endActive();\n\n        // $FlowFixMe incompatible-call\n        const resultPromise = ZalgoPromise.resolve(result);\n\n        return resultPromise;\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        return awaitActive(ZalgoPromise);\n    }\n}\n","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","/* @flow */\n\nexport const PROTOCOL = {\n  MOCK: (\"mock:\": \"mock:\"),\n  FILE: (\"file:\": \"file:\"),\n  ABOUT: (\"about:\": \"about:\"),\n};\n\nexport const WILDCARD = \"*\";\n\nexport const WINDOW_TYPE = {\n  IFRAME: (\"iframe\": \"iframe\"),\n  POPUP: (\"popup\": \"popup\"),\n};\n","/* @flow */\n/* eslint max-lines: 0 */\n\nimport { isRegex, noop } from \"./util\";\nimport type {\n  CrossDomainWindowType,\n  SameDomainWindowType,\n  DomainMatcher,\n} from \"./types\";\nimport { PROTOCOL, WILDCARD } from \"./constants\";\n\nconst IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\nexport function getActualProtocol(win: SameDomainWindowType = window): ?string {\n  return win.location.protocol;\n}\n\nexport function getProtocol(win: SameDomainWindowType = window): ?string {\n  if (win.mockDomain) {\n    const protocol = win.mockDomain.split(\"//\")[0];\n\n    if (protocol) {\n      return protocol;\n    }\n  }\n\n  return getActualProtocol(win);\n}\n\nexport function isFileProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.FILE;\n}\n\nexport function isAboutProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.ABOUT;\n}\n\nexport function isMockProtocol(win: SameDomainWindowType = window): boolean {\n  return getProtocol(win) === PROTOCOL.MOCK;\n}\n\nexport function getParent(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  if (!win) {\n    return;\n  }\n\n  try {\n    if (win.parent && win.parent !== win) {\n      return win.parent;\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function getOpener(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  if (!win) {\n    return;\n  }\n\n  // Make sure we're not actually an iframe which has had window.open() called on us\n  if (getParent(win)) {\n    return;\n  }\n\n  try {\n    return win.opener;\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function canReadFromWindow(\n  win: CrossDomainWindowType | SameDomainWindowType\n): boolean {\n  try {\n    // $FlowFixMe\n    noop(win && win.location && win.location.href);\n    return true;\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function getActualDomain(win?: SameDomainWindowType = window): string {\n  const location = win.location;\n\n  if (!location) {\n    throw new Error(`Can not read window location`);\n  }\n\n  const protocol = getActualProtocol(win);\n\n  if (!protocol) {\n    throw new Error(`Can not read window protocol`);\n  }\n\n  if (protocol === PROTOCOL.FILE) {\n    return `${PROTOCOL.FILE}//`;\n  }\n\n  if (protocol === PROTOCOL.ABOUT) {\n    const parent = getParent(win);\n    if (parent && canReadFromWindow(parent)) {\n      // $FlowFixMe\n      return getActualDomain(parent);\n    }\n\n    return `${PROTOCOL.ABOUT}//`;\n  }\n\n  const host = location.host;\n\n  if (!host) {\n    throw new Error(`Can not read window host`);\n  }\n\n  return `${protocol}//${host}`;\n}\n\nexport function getDomain(win?: SameDomainWindowType = window): string {\n  const domain = getActualDomain(win);\n\n  if (domain && win.mockDomain && win.mockDomain.indexOf(PROTOCOL.MOCK) === 0) {\n    return win.mockDomain;\n  }\n\n  return domain;\n}\n\nexport function isBlankDomain(win: CrossDomainWindowType): boolean {\n  try {\n    // $FlowFixMe\n    if (!win.location.href) {\n      return true;\n    }\n\n    if (win.location.href === \"about:blank\") {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isActuallySameDomain(win: CrossDomainWindowType): boolean {\n  try {\n    if (win === window) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    const desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\n    if (desc && desc.enumerable === false) {\n      return false;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (isAboutProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (isMockProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    // $FlowFixMe\n    if (getActualDomain(win) === getActualDomain(window)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isSameDomain(\n  win: CrossDomainWindowType | SameDomainWindowType\n): boolean {\n  if (!isActuallySameDomain(win)) {\n    return false;\n  }\n\n  try {\n    if (win === window) {\n      return true;\n    }\n\n    // $FlowFixMe\n    if (isAboutProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n\n    // $FlowFixMe\n    if (getDomain(window) === getDomain(win)) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function assertSameDomain(\n  win: CrossDomainWindowType | SameDomainWindowType\n): SameDomainWindowType {\n  if (!isSameDomain(win)) {\n    throw new Error(`Expected window to be same domain`);\n  }\n\n  // $FlowFixMe\n  return win;\n}\n\nexport function getParents(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  try {\n    while (win.parent !== win) {\n      result.push(win.parent);\n      win = win.parent;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return result;\n}\n\nexport function isAncestorParent(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  if (!parent || !child) {\n    return false;\n  }\n\n  const childParent = getParent(child);\n\n  if (childParent) {\n    return childParent === parent;\n  }\n\n  if (getParents(child).indexOf(parent) !== -1) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function getFrames(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  let frames;\n\n  try {\n    frames = win.frames;\n  } catch (err) {\n    frames = win;\n  }\n\n  let len;\n\n  try {\n    len = frames.length;\n  } catch (err) {\n    // pass\n  }\n\n  if (len === 0) {\n    return result;\n  }\n\n  if (len) {\n    for (let i = 0; i < len; i++) {\n      let frame;\n\n      try {\n        frame = frames[i];\n      } catch (err) {\n        continue;\n      }\n\n      result.push(frame);\n    }\n\n    return result;\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let frame;\n\n    try {\n      frame = frames[i];\n    } catch (err) {\n      return result;\n    }\n\n    if (!frame) {\n      return result;\n    }\n\n    result.push(frame);\n  }\n\n  return result;\n}\n\nexport function getAllChildFrames(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const result = [];\n\n  for (const frame of getFrames(win)) {\n    result.push(frame);\n\n    for (const childFrame of getAllChildFrames(frame)) {\n      result.push(childFrame);\n    }\n  }\n\n  return result;\n}\n\nexport function getTop(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  try {\n    if (win.top) {\n      return win.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  if (getParent(win) === win) {\n    return win;\n  }\n\n  try {\n    if (isAncestorParent(window, win) && window.top) {\n      return window.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    if (isAncestorParent(win, window) && window.top) {\n      return window.top;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  for (const frame of getAllChildFrames(win)) {\n    try {\n      if (frame.top) {\n        return frame.top;\n      }\n    } catch (err) {\n      // pass\n    }\n\n    if (getParent(frame) === frame) {\n      return frame;\n    }\n  }\n}\n\nexport function getNextOpener(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  return getOpener(getTop(win) || win);\n}\n\nexport function getUltimateTop(\n  win?: CrossDomainWindowType = window\n): CrossDomainWindowType {\n  const opener = getNextOpener(win);\n\n  if (opener) {\n    return getUltimateTop(opener);\n  }\n\n  return top;\n}\n\nexport function getAllFramesInWindow(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const top = getTop(win);\n\n  if (!top) {\n    throw new Error(`Can not determine top window`);\n  }\n\n  let result = [...getAllChildFrames(top), top];\n\n  // Win may be in shadow dom\n  if (result.indexOf(win) === -1) {\n    result = [...result, win, ...getAllChildFrames(win)];\n  }\n\n  return result;\n}\n\nexport function getAllWindows(\n  win?: CrossDomainWindowType = window\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const frames = getAllFramesInWindow(win);\n  const opener = getNextOpener(win);\n\n  if (opener) {\n    return [...getAllWindows(opener), ...frames];\n  } else {\n    return frames;\n  }\n}\n\nexport function isTop(win: CrossDomainWindowType): boolean {\n  return win === getTop(win);\n}\n\nexport function isFrameWindowClosed(frame: HTMLIFrameElement): boolean {\n  if (!frame.contentWindow) {\n    return true;\n  }\n\n  if (!frame.parentNode) {\n    return true;\n  }\n\n  const doc = frame.ownerDocument;\n\n  if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n    let parent = frame;\n\n    while (parent.parentNode && parent.parentNode !== parent) {\n      parent = parent.parentNode;\n    }\n\n    // $FlowFixMe\n    if (!parent.host || !doc.documentElement.contains(parent.host)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction safeIndexOf<T>(collection: $ReadOnlyArray<T>, item: T): number {\n  for (let i = 0; i < collection.length; i++) {\n    try {\n      if (collection[i] === item) {\n        return i;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  return -1;\n}\n\nconst iframeWindows = [];\nconst iframeFrames = [];\n\nexport function isWindowClosed(\n  win: CrossDomainWindowType,\n  allowMock: boolean = true\n): boolean {\n  try {\n    if (win === window) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (!win) {\n      return true;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (win.closed) {\n      return true;\n    }\n  } catch (err) {\n    // I love you so much IE\n\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (allowMock && isSameDomain(win)) {\n    try {\n      // $FlowFixMe\n      if (win.mockclosed) {\n        return true;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  // Mobile safari\n\n  try {\n    if (!win.parent || !win.top) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  // Yes, this actually happens in IE. win === win errors out when the window\n  // is from an iframe, and the iframe was removed from the page.\n\n  try {\n    noop(win === win); // eslint-disable-line no-self-compare\n  } catch (err) {\n    return true;\n  }\n\n  // IE orphaned frame\n\n  const iframeIndex = safeIndexOf(iframeWindows, win);\n\n  if (iframeIndex !== -1) {\n    const frame = iframeFrames[iframeIndex];\n\n    if (frame && isFrameWindowClosed(frame)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction cleanIframes() {\n  for (let i = 0; i < iframeWindows.length; i++) {\n    let closed = false;\n\n    try {\n      closed = iframeWindows[i].closed;\n    } catch (err) {\n      // pass\n    }\n\n    if (closed) {\n      iframeFrames.splice(i, 1);\n      iframeWindows.splice(i, 1);\n    }\n  }\n}\n\nexport function linkFrameWindow(frame: HTMLIFrameElement) {\n  cleanIframes();\n\n  if (frame && frame.contentWindow) {\n    try {\n      iframeWindows.push(frame.contentWindow);\n      iframeFrames.push(frame);\n    } catch (err) {\n      // pass\n    }\n  }\n}\n\nexport function getUserAgent(win: ?SameDomainWindowType): string {\n  win = win || window;\n  return win.navigator.mockUserAgent || win.navigator.userAgent;\n}\n\nexport function getFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const winFrames = getFrames(win);\n\n  for (const childFrame of winFrames) {\n    try {\n      if (\n        isSameDomain(childFrame) &&\n        // $FlowFixMe\n        childFrame.name === name &&\n        winFrames.indexOf(childFrame) !== -1\n      ) {\n        return childFrame;\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  try {\n    // $FlowFixMe\n    if (winFrames.indexOf(win.frames[name]) !== -1) {\n      // $FlowFixMe\n      return win.frames[name];\n    }\n  } catch (err) {\n    // pass\n  }\n\n  try {\n    if (winFrames.indexOf(win[name]) !== -1) {\n      return win[name];\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nexport function findChildFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const frame = getFrameByName(win, name);\n\n  if (frame) {\n    return frame;\n  }\n\n  for (const childFrame of getFrames(win)) {\n    const namedFrame = findChildFrameByName(childFrame, name);\n\n    if (namedFrame) {\n      return namedFrame;\n    }\n  }\n}\n\nexport function findFrameByName(\n  win: CrossDomainWindowType,\n  name: string\n): ?CrossDomainWindowType {\n  const frame = getFrameByName(win, name);\n\n  if (frame) {\n    return frame;\n  }\n\n  const top = getTop(win) || win;\n\n  return findChildFrameByName(top, name);\n}\n\nexport function isParent(\n  win: CrossDomainWindowType,\n  frame: CrossDomainWindowType\n): boolean {\n  const frameParent = getParent(frame);\n\n  if (frameParent) {\n    return frameParent === win;\n  }\n\n  for (const childFrame of getFrames(win)) {\n    if (childFrame === frame) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isOpener(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  return parent === getOpener(child);\n}\n\nexport function getAncestor(\n  win?: CrossDomainWindowType = window\n): ?CrossDomainWindowType {\n  win = win || window;\n\n  const opener = getOpener(win);\n\n  if (opener) {\n    return opener;\n  }\n\n  const parent = getParent(win);\n\n  if (parent) {\n    return parent;\n  }\n}\n\nexport function getAncestors(\n  win: CrossDomainWindowType\n): $ReadOnlyArray<CrossDomainWindowType> {\n  const results = [];\n\n  let ancestor = win;\n\n  while (ancestor) {\n    ancestor = getAncestor(ancestor);\n    if (ancestor) {\n      results.push(ancestor);\n    }\n  }\n\n  return results;\n}\n\nexport function isAncestor(\n  parent: CrossDomainWindowType,\n  child: CrossDomainWindowType\n): boolean {\n  const actualParent = getAncestor(child);\n\n  if (actualParent) {\n    if (actualParent === parent) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (child === parent) {\n    return false;\n  }\n\n  if (getTop(child) === child) {\n    return false;\n  }\n\n  for (const frame of getFrames(parent)) {\n    if (frame === child) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isPopup(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(getOpener(win));\n}\n\nexport function isIframe(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(getParent(win));\n}\n\nexport function isFullpage(win?: CrossDomainWindowType = window): boolean {\n  return Boolean(!isIframe(win) && !isPopup(win));\n}\n\nfunction anyMatch(collection1, collection2): boolean {\n  for (const item1 of collection1) {\n    for (const item2 of collection2) {\n      if (item1 === item2) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function getDistanceFromTop(\n  win: CrossDomainWindowType = window\n): number {\n  let distance = 0;\n  let parent = win;\n\n  while (parent) {\n    parent = getParent(parent);\n    if (parent) {\n      distance += 1;\n    }\n  }\n\n  return distance;\n}\n\nexport function getNthParent(\n  win: CrossDomainWindowType,\n  n: number = 1\n): ?CrossDomainWindowType {\n  let parent = win;\n\n  for (let i = 0; i < n; i++) {\n    if (!parent) {\n      return;\n    }\n\n    parent = getParent(parent);\n  }\n\n  return parent;\n}\n\nexport function getNthParentFromTop(\n  win: CrossDomainWindowType,\n  n: number = 1\n): ?CrossDomainWindowType {\n  return getNthParent(win, getDistanceFromTop(win) - n);\n}\n\nexport function isSameTopWindow(\n  win1: CrossDomainWindowType,\n  win2: CrossDomainWindowType\n): boolean {\n  const top1 = getTop(win1) || win1;\n  const top2 = getTop(win2) || win2;\n\n  try {\n    if (top1 && top2) {\n      if (top1 === top2) {\n        return true;\n      }\n\n      return false;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  const allFrames1 = getAllFramesInWindow(win1);\n  const allFrames2 = getAllFramesInWindow(win2);\n\n  if (anyMatch(allFrames1, allFrames2)) {\n    return true;\n  }\n\n  const opener1 = getOpener(top1);\n  const opener2 = getOpener(top2);\n\n  if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) {\n    return false;\n  }\n\n  if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) {\n    return false;\n  }\n\n  return false;\n}\n\nexport function matchDomain(\n  pattern: DomainMatcher,\n  origin: DomainMatcher\n): boolean {\n  if (typeof pattern === \"string\") {\n    if (typeof origin === \"string\") {\n      return pattern === WILDCARD || origin === pattern;\n    }\n\n    if (isRegex(origin)) {\n      return false;\n    }\n\n    if (Array.isArray(origin)) {\n      return false;\n    }\n  }\n\n  if (isRegex(pattern)) {\n    if (isRegex(origin)) {\n      return pattern.toString() === origin.toString();\n    }\n\n    if (Array.isArray(origin)) {\n      return false;\n    }\n\n    // $FlowFixMe\n    return Boolean(origin.match(pattern));\n  }\n\n  if (Array.isArray(pattern)) {\n    if (Array.isArray(origin)) {\n      return JSON.stringify(pattern) === JSON.stringify(origin);\n    }\n\n    if (isRegex(origin)) {\n      return false;\n    }\n\n    return pattern.some((subpattern) => matchDomain(subpattern, origin));\n  }\n\n  return false;\n}\n\nexport function stringifyDomainPattern(pattern: DomainMatcher): string {\n  if (Array.isArray(pattern)) {\n    return `(${pattern.join(\" | \")})`;\n  } else if (isRegex(pattern)) {\n    return `RegExp(${pattern.toString()})`;\n  } else {\n    return pattern.toString();\n  }\n}\n\nexport function getDomainFromUrl(url: string): string {\n  let domain;\n\n  if (url.match(/^(https?|mock|file):\\/\\//)) {\n    domain = url;\n  } else {\n    return getDomain();\n  }\n\n  domain = domain.split(\"/\").slice(0, 3).join(\"/\");\n\n  return domain;\n}\n\nexport function onCloseWindow(\n  win: CrossDomainWindowType,\n  callback: Function,\n  delay: number = 1000,\n  maxtime: number = Infinity\n): {| cancel: () => void |} {\n  let timeout;\n\n  const check = () => {\n    if (isWindowClosed(win)) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      return callback();\n    }\n\n    if (maxtime <= 0) {\n      clearTimeout(timeout);\n    } else {\n      maxtime -= delay;\n      timeout = setTimeout(check, delay);\n    }\n  };\n\n  check();\n\n  return {\n    cancel() {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    },\n  };\n}\n\n// eslint-disable-next-line complexity\nexport function isWindow(obj: Object): boolean {\n  try {\n    if (obj === window) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    // $FlowFixMe method-unbinding\n    if (Object.prototype.toString.call(obj) === \"[object Window]\") {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (window.Window && obj instanceof window.Window) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.self === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.parent === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.top === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    // eslint-disable-next-line no-self-compare\n    if (noop(obj === obj) === \"__unlikely_value__\") {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (\n      obj &&\n      obj.__cross_domain_utils_window_check__ === \"__unlikely_value__\"\n    ) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) {\n      return true;\n    }\n  } catch (err) {\n    // pass\n  }\n\n  return false;\n}\n\nexport function isBrowser(): boolean {\n  return (\n    typeof window !== \"undefined\" && typeof window.location !== \"undefined\"\n  );\n}\n\nexport function isCurrentDomain(domain: string): boolean {\n  if (!isBrowser()) {\n    return false;\n  }\n\n  return getDomain() === domain;\n}\n\nexport function isMockDomain(domain: string): boolean {\n  return domain.indexOf(PROTOCOL.MOCK) === 0;\n}\n\nexport function normalizeMockUrl(url: string): string {\n  if (!isMockDomain(getDomainFromUrl(url))) {\n    return url;\n  }\n\n  if (!__TEST__) {\n    throw new Error(`Mock urls not supported out of test mode`);\n  }\n\n  return url.replace(/^mock:\\/\\/[^/]+/, getActualDomain(window));\n}\n\nexport function getFrameForWindow(win: CrossDomainWindowType): ?HTMLElement {\n  if (isSameDomain(win)) {\n    return assertSameDomain(win).frameElement;\n  }\n\n  for (const frame of document.querySelectorAll(\"iframe\")) {\n    if (frame && frame.contentWindow && frame.contentWindow === win) {\n      return frame;\n    }\n  }\n}\n\nexport function closeWindow(win: CrossDomainWindowType) {\n  if (isIframe(win)) {\n    const frame = getFrameForWindow(win);\n    if (frame && frame.parentElement) {\n      frame.parentElement.removeChild(frame);\n      return;\n    }\n  }\n\n  try {\n    win.close();\n  } catch (err) {\n    // pass\n  }\n}\n","/* @flow */\n\nexport function safeIndexOf<T>(collection : $ReadOnlyArray<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : $ReadOnlyArray<mixed>) {\n    // pass\n}\n","/* @flow */\n\nimport { isWindow, isWindowClosed } from '@krakenjs/cross-domain-utils/src';\n\nimport { hasNativeWeakMap } from './native';\nimport { noop, safeIndexOf } from './util';\n\nexport class CrossDomainSafeWeakMap<K : Object, V : mixed> {\n\n    name : string;\n    weakmap : ?WeakMap<K, V>;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    keys : Array<K>;\n    // eslint-disable-next-line flowtype/no-mutable-array\n    values : Array<V>;\n\n    constructor() {\n        // eslint-disable-next-line no-bitwise\n        this.name = `__weakmap_${ Math.random() * 1e9 >>> 0 }__`;\n\n        if (hasNativeWeakMap()) {\n            try {\n                this.weakmap = new WeakMap();\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this.keys  = [];\n        this.values = [];\n    }\n\n    _cleanupClosedWindows() {\n\n        const weakmap = this.weakmap;\n        const keys = this.keys;\n\n        for (let i = 0; i < keys.length; i++) {\n            const value = keys[i];\n\n            if (isWindow(value) && isWindowClosed(value)) {\n\n                if (weakmap) {\n                    try {\n                        weakmap.delete(value);\n                    } catch (err) {\n                        // pass\n                    }\n                }\n\n                keys.splice(i, 1);\n                this.values.splice(i, 1);\n\n                i -= 1;\n            }\n        }\n    }\n\n    isSafeToReadWrite(key : K) : boolean {\n\n        if (isWindow(key)) {\n            return false;\n        }\n\n        try {\n            noop(key && key.self);\n            noop(key && key[this.name]);\n        } catch (err) {\n            return false;\n        }\n\n        return true;\n    }\n\n    set(key : K, value : V) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.set(key, value);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const name = this.name;\n                const entry = key[name];\n\n                if (entry && entry[0] === key) {\n                    entry[1] = value;\n                } else {\n                    Object.defineProperty(key, name, {\n                        value:    [ key, value ],\n                        writable: true\n                    });\n                }\n\n                return;\n\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const values = this.values;\n        const index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            keys.push(key);\n            values.push(value);\n        } else {\n            values[index] = value;\n        }\n    }\n\n    get(key : K) : V | void {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return weakmap.get(key);\n                }\n\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return entry[1];\n                }\n\n                return;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            return;\n        }\n\n        return this.values[index];\n    }\n\n    delete(key : K) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.delete(key);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    entry[0] = entry[1] = undefined;\n                }\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const index = safeIndexOf(keys, key);\n\n        if (index !== -1) {\n            keys.splice(index, 1);\n            this.values.splice(index, 1);\n        }\n    }\n\n    has(key : K) : boolean {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return true;\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return true;\n                }\n\n                return false;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const index = safeIndexOf(this.keys, key);\n        return index !== -1;\n    }\n\n    getOrSet(key : K, getter : () => V) : V {\n        if (this.has(key)) {\n            // $FlowFixMe\n            return this.get(key);\n        }\n\n        const value = getter();\n        this.set(key, value);\n        return value;\n    }\n}\n","/* @flow */\n/* eslint max-lines: 0 */\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { WeakMap } from \"@krakenjs/cross-domain-safe-weakmap/src\";\n\nimport {\n  BLANK_URL,\n  ctrlCharactersRegex,\n  htmlCtrlEntityRegex,\n  htmlEntitiesRegex,\n  invalidProtocolRegex,\n  relativeFirstCharacters,\n  urlSchemeRegex,\n} from \"./constants\";\nimport type { CancelableType } from \"./types\";\n\nexport function isElement(element: mixed): boolean {\n  let passed = false;\n\n  try {\n    if (element instanceof window.Element) {\n      passed = true;\n    } else if (\n      element !== null &&\n      typeof element === \"object\" &&\n      element.nodeType === 1 &&\n      typeof element.style === \"object\" &&\n      typeof element.ownerDocument === \"object\"\n    ) {\n      passed = true;\n    }\n  } catch (_) {\n    // we don't have an element\n  }\n\n  return passed;\n}\n\nexport function getFunctionName<T: Function>(fn: T): string {\n  return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n}\n\nexport function setFunctionName<T: Function>(fn: T, name: string): T {\n  try {\n    delete fn.name;\n    fn.name = name;\n  } catch (err) {\n    // pass\n  }\n\n  fn.__name__ = fn.displayName = name;\n  return fn;\n}\n\nexport function base64encode(str: string): string {\n  if (typeof btoa === \"function\") {\n    return btoa(\n      encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (m, p1) => {\n        return String.fromCharCode(parseInt(p1, 16));\n      })\n    ).replace(/[=]/g, \"\");\n  }\n\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n  }\n\n  throw new Error(`Can not find window.btoa or Buffer`);\n}\n\nexport function base64decode(str: string): string {\n  if (typeof atob === \"function\") {\n    return decodeURIComponent(\n      // $FlowFixMe[method-unbinding]\n      Array.prototype.map\n        .call(atob(str), (c) => {\n          // eslint-disable-next-line prefer-template\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n  }\n\n  if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(str, \"base64\").toString(\"utf8\");\n  }\n\n  throw new Error(`Can not find window.atob or Buffer`);\n}\n\nexport function uniqueID(): string {\n  const chars = \"0123456789abcdef\";\n\n  const randomID = \"xxxxxxxxxx\".replace(/./g, () => {\n    return chars.charAt(Math.floor(Math.random() * chars.length));\n  });\n\n  const timeID = base64encode(\n    new Date().toISOString().slice(11, 19).replace(\"T\", \".\")\n  )\n    .replace(/[^a-zA-Z0-9]/g, \"\")\n    .toLowerCase();\n\n  return `uid_${randomID}_${timeID}`;\n}\n\nexport function getGlobal(): Object {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  if (typeof __GLOBAL__ !== \"undefined\") {\n    return __GLOBAL__;\n  }\n  throw new Error(`No global found`);\n}\n\nlet objectIDs;\n\nexport function getObjectID(obj: Object): string {\n  objectIDs = objectIDs || new WeakMap();\n\n  if (\n    obj === null ||\n    obj === undefined ||\n    (typeof obj !== \"object\" && typeof obj !== \"function\")\n  ) {\n    throw new Error(`Invalid object`);\n  }\n\n  let uid = objectIDs.get(obj);\n\n  if (!uid) {\n    uid = `${typeof obj}:${uniqueID()}`;\n    objectIDs.set(obj, uid);\n  }\n\n  return uid;\n}\n\nfunction serializeArgs<T>(args: $ReadOnlyArray<T>): string {\n  try {\n    // $FlowFixMe[method-unbinding]\n    return JSON.stringify(Array.prototype.slice.call(args), (subkey, val) => {\n      // Treat each distinct function as unique for purposes of memoization\n      // e.g. even if someFunction.stringify() is the same, we may use a different memoize cache\n      // if the actual function is different.\n      if (typeof val === \"function\") {\n        return `memoize[${getObjectID(val)}]`;\n      }\n\n      // By default JSON.stringify(domElement) returns '{}'. This ensures that stays true even for non-standard\n      // elements (e.g. React-rendered dom elements) with custom properties\n      if (isElement(val)) {\n        return {};\n      }\n\n      return val;\n    });\n  } catch (err) {\n    throw new Error(`Arguments not serializable -- can not be used to memoize`);\n  }\n}\n\nexport function getEmptyObject(): {||} {\n  // $FlowFixMe\n  return {};\n}\n\ntype MemoizeOptions = {|\n  name?: string,\n  time?: number,\n  thisNamespace?: boolean,\n|};\n\nconst getDefaultMemoizeOptions = (): MemoizeOptions => {\n  // $FlowFixMe\n  return {};\n};\n\nexport type Memoized<F> = F & {| reset: () => void |};\n\nlet memoizeGlobalIndex = 0;\nlet memoizeGlobalIndexValidFrom = 0;\n\nexport function memoize<F: Function>(\n  method: F,\n  options?: MemoizeOptions = getDefaultMemoizeOptions()\n): Memoized<F> {\n  const { thisNamespace = false, time: cacheTime } = options;\n\n  let simpleCache;\n  let thisCache;\n\n  let memoizeIndex = memoizeGlobalIndex;\n  memoizeGlobalIndex += 1;\n\n  const memoizedFunction = function memoizedFunction(...args): mixed {\n    if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n      simpleCache = null;\n      thisCache = null;\n      memoizeIndex = memoizeGlobalIndex;\n      memoizeGlobalIndex += 1;\n    }\n\n    let cache;\n\n    if (thisNamespace) {\n      thisCache = thisCache || new WeakMap();\n      cache = thisCache.getOrSet(this, getEmptyObject);\n    } else {\n      cache = simpleCache = simpleCache || {};\n    }\n\n    let cacheKey;\n\n    try {\n      cacheKey = serializeArgs(args);\n    } catch {\n      return method.apply(this, arguments);\n    }\n\n    let cacheResult = cache[cacheKey];\n\n    if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n      delete cache[cacheKey];\n      cacheResult = null;\n    }\n\n    if (cacheResult) {\n      return cacheResult.value;\n    }\n\n    const time = Date.now();\n    const value = method.apply(this, arguments);\n\n    cache[cacheKey] = { time, value };\n\n    return value;\n  };\n\n  memoizedFunction.reset = () => {\n    simpleCache = null;\n    thisCache = null;\n  };\n\n  // $FlowFixMe\n  const result: F = memoizedFunction;\n\n  return setFunctionName(\n    result,\n    `${options.name || getFunctionName(method)}::memoized`\n  );\n}\n\nmemoize.clear = () => {\n  memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n};\n\nexport function promiseIdentity<T: mixed>(\n  item: ZalgoPromise<T> | T\n): ZalgoPromise<T> {\n  // $FlowFixMe\n  return ZalgoPromise.resolve(item);\n}\n\nexport function memoizePromise<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => ZalgoPromise<R>\n  // eslint-disable-next-line flowtype/no-weak-types\n): (...args: $ReadOnlyArray<any>) => ZalgoPromise<R> {\n  let cache = {};\n\n  function memoizedPromiseFunction(\n    // eslint-disable-next-line flowtype/no-weak-types\n    ...args: $ReadOnlyArray<any>\n  ): ZalgoPromise<R> {\n    const key: string = serializeArgs(args);\n\n    if (cache.hasOwnProperty(key)) {\n      return cache[key];\n    }\n\n    cache[key] = ZalgoPromise.try(() => method.apply(this, arguments)).finally(\n      () => {\n        delete cache[key];\n      }\n    );\n\n    return cache[key];\n  }\n\n  memoizedPromiseFunction.reset = () => {\n    cache = {};\n  };\n\n  return setFunctionName(\n    memoizedPromiseFunction,\n    `${getFunctionName(method)}::promiseMemoized`\n  );\n}\n\ntype PromisifyOptions = {|\n  name?: string,\n|};\n\nconst getDefaultPromisifyOptions = (): PromisifyOptions => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function promisify<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => R,\n  options: PromisifyOptions = getDefaultPromisifyOptions()\n  // eslint-disable-next-line flowtype/no-weak-types\n): (...args: $ReadOnlyArray<any>) => ZalgoPromise<R> {\n  function promisifiedFunction(): ZalgoPromise<R> {\n    return ZalgoPromise.try(method, this, arguments);\n  }\n\n  if (options.name) {\n    promisifiedFunction.displayName = `${options.name}:promisified`;\n  }\n\n  return setFunctionName(\n    promisifiedFunction,\n    `${getFunctionName(method)}::promisified`\n  );\n}\n\nexport function inlineMemoize<R>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (...args: $ReadOnlyArray<any>) => R,\n  // eslint-disable-next-line flowtype/no-weak-types\n  logic: (...args: $ReadOnlyArray<any>) => R,\n  // eslint-disable-next-line flowtype/no-weak-types\n  args: $ReadOnlyArray<any> = []\n): R {\n  // $FlowFixMe\n  const cache: {| [string]: R |} = (method.__inline_memoize_cache__ =\n    // $FlowFixMe\n    method.__inline_memoize_cache__ || {});\n  const key = serializeArgs(args);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  const result = (cache[key] = logic(...args));\n\n  return result;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args: $ReadOnlyArray<mixed>) {\n  // pass\n}\n\nexport function once(method: Function): Function {\n  let called = false;\n\n  const onceFunction = function (): mixed {\n    if (!called) {\n      called = true;\n      return method.apply(this, arguments);\n    }\n  };\n\n  return setFunctionName(onceFunction, `${getFunctionName(method)}::once`);\n}\n\nexport function hashStr(str: string): number {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash += str[i].charCodeAt(0) * Math.pow((i % 10) + 1, 5);\n  }\n  return Math.floor(Math.pow(Math.sqrt(hash), 5));\n}\n\nexport function strHashStr(str: string): string {\n  let hash = \"\";\n\n  for (let i = 0; i < str.length; i++) {\n    let total = str[i].charCodeAt(0) * i;\n\n    if (str[i + 1]) {\n      total += str[i + 1].charCodeAt(0) * (i - 1);\n    }\n\n    hash += String.fromCharCode(97 + (Math.abs(total) % 26));\n  }\n\n  return hash;\n}\n\nexport function match(str: string, pattern: RegExp): ?string {\n  const regmatch = str.match(pattern);\n  if (regmatch) {\n    return regmatch[1];\n  }\n}\n\nexport function awaitKey<T: mixed>(obj: Object, key: string): ZalgoPromise<T> {\n  return new ZalgoPromise((resolve) => {\n    let value = obj[key];\n\n    if (value) {\n      return resolve(value);\n    }\n\n    delete obj[key];\n\n    Object.defineProperty(obj, key, {\n      configurable: true,\n\n      set(item) {\n        value = item;\n\n        if (value) {\n          resolve(value);\n        }\n      },\n\n      get(): T {\n        return value;\n      },\n    });\n  });\n}\n\nexport function stringifyError(err: mixed, level: number = 1): string {\n  if (level >= 3) {\n    return \"stringifyError stack overflow\";\n  }\n\n  try {\n    if (!err) {\n      // $FlowFixMe[method-unbinding]\n      return `<unknown error: ${Object.prototype.toString.call(err)}>`;\n    }\n\n    if (typeof err === \"string\") {\n      return err;\n    }\n\n    if (err instanceof Error) {\n      const stack = err && err.stack;\n      const message = err && err.message;\n\n      if (stack && message) {\n        if (stack.indexOf(message) !== -1) {\n          return stack;\n        } else {\n          return `${message}\\n${stack}`;\n        }\n      } else if (stack) {\n        return stack;\n      } else if (message) {\n        return message;\n      }\n    }\n\n    if (err && err.toString && typeof err.toString === \"function\") {\n      // $FlowFixMe\n      return err.toString();\n    }\n\n    // $FlowFixMe[method-unbinding]\n    return Object.prototype.toString.call(err);\n  } catch (newErr) {\n    return `Error while stringifying error: ${stringifyError(\n      newErr,\n      level + 1\n    )}`;\n  }\n}\n\nexport function stringifyErrorMessage(err: mixed): string {\n  // $FlowFixMe[method-unbinding]\n  const defaultMessage = `<unknown error: ${Object.prototype.toString.call(\n    err\n  )}>`;\n\n  if (!err) {\n    return defaultMessage;\n  }\n\n  if (err instanceof Error) {\n    return err.message || defaultMessage;\n  }\n\n  if (typeof err.message === \"string\") {\n    return err.message || defaultMessage;\n  }\n\n  return defaultMessage;\n}\n\nexport function stringify(item: mixed): string {\n  if (typeof item === \"string\") {\n    return item;\n  }\n\n  if (item && item.toString && typeof item.toString === \"function\") {\n    // $FlowFixMe\n    return item.toString();\n  }\n\n  // $FlowFixMe[method-unbinding]\n  return Object.prototype.toString.call(item);\n}\n\nexport function domainMatches(hostname: string, domain: string): boolean {\n  hostname = hostname.split(\"://\")[1];\n  const index = hostname.indexOf(domain);\n  return index !== -1 && hostname.slice(index) === domain;\n}\n\nexport function patchMethod(obj: Object, name: string, handler: Function) {\n  const original = obj[name];\n\n  obj[name] = function patchedMethod(): mixed {\n    return handler({\n      context: this,\n      // $FlowFixMe[method-unbinding]\n      args: Array.prototype.slice.call(arguments),\n      original,\n      callOriginal: () => original.apply(this, arguments),\n    });\n  };\n}\n\nexport function extend<T: Object | Function>(obj: T, source: Object): T {\n  if (!source) {\n    return obj;\n  }\n\n  if (Object.assign) {\n    return Object.assign(obj, source);\n  }\n\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      obj[key] = source[key];\n    }\n  }\n\n  return obj;\n}\n\nexport function values<T>(obj: { [string]: T }): $ReadOnlyArray<T> {\n  if (Object.values) {\n    // $FlowFixMe\n    return Object.values(obj);\n  }\n\n  const result: Array<T> = [];\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      // $FlowFixMe[escaped-generic]\n      result.push(obj[key]);\n    }\n  }\n\n  // $FlowFixMe\n  return result;\n}\n\n// eslint-disable-next-line no-undef\nexport const memoizedValues: <T>({ [string]: T }) => $ReadOnlyArray<T> =\n  memoize(values);\n\nexport function perc(pixels: number, percentage: number): number {\n  return Math.round((pixels * percentage) / 100);\n}\n\nexport function min(...args: $ReadOnlyArray<number>): number {\n  return Math.min(...args);\n}\n\nexport function max(...args: $ReadOnlyArray<number>): number {\n  return Math.max(...args);\n}\n\nexport function roundUp(num: number, nearest: number): number {\n  const remainder = num % nearest;\n  return remainder ? num - remainder + nearest : num;\n}\n\nexport function regexMap<T>(\n  str: string,\n  regexp: RegExp,\n  handler: () => T\n): $ReadOnlyArray<T> {\n  const results = [];\n\n  // $FlowFixMe\n  str.replace(regexp, function regexMapMatcher(item) {\n    results.push(handler ? handler.apply(null, arguments) : item);\n  });\n\n  // $FlowFixMe\n  return results;\n}\n\nexport function svgToBase64(svg: string): string {\n  return `data:image/svg+xml;base64,${base64encode(svg)}`;\n}\n\nexport function objFilter<T, R>(\n  obj: { [string]: T },\n  filter?: (T, ?string) => mixed = Boolean\n): { [string]: R } {\n  const result = {};\n\n  for (const key in obj) {\n    if (!obj.hasOwnProperty(key) || !filter(obj[key], key)) {\n      continue;\n    }\n\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nexport function identity<T>(item: T): T {\n  return item;\n}\n\nexport function regexTokenize(\n  text: string,\n  regexp: RegExp\n): $ReadOnlyArray<string> {\n  const result = [];\n  text.replace(regexp, (token) => {\n    result.push(token);\n    return \"\";\n  });\n  return result;\n}\n\nexport function promiseDebounce<T>(\n  method: () => ZalgoPromise<T> | T,\n  delay: number = 50\n): () => ZalgoPromise<T> {\n  let promise;\n  let timeout;\n\n  const promiseDebounced = function (): ZalgoPromise<T> {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    const localPromise = (promise = promise || new ZalgoPromise());\n\n    timeout = setTimeout(() => {\n      promise = null;\n      timeout = null;\n\n      ZalgoPromise.try(method).then(\n        (result) => {\n          localPromise.resolve(result);\n        },\n        (err) => {\n          localPromise.reject(err);\n        }\n      );\n    }, delay);\n\n    return localPromise;\n  };\n\n  return setFunctionName(\n    promiseDebounced,\n    `${getFunctionName(method)}::promiseDebounced`\n  );\n}\n\nexport function safeInterval(\n  method: Function,\n  time: number\n): {| cancel: () => void |} {\n  let timeout;\n\n  function loop() {\n    timeout = setTimeout(() => {\n      method();\n      loop();\n    }, time);\n  }\n\n  loop();\n\n  return {\n    cancel() {\n      clearTimeout(timeout);\n    },\n  };\n}\n\nexport function isInteger(str: string): boolean {\n  return Boolean(str.match(/^[0-9]+$/));\n}\n\nexport function isFloat(str: string): boolean {\n  return Boolean(str.match(/^[0-9]+\\.[0-9]+$/));\n}\n\nexport function serializePrimitive(value: string | number | boolean): string {\n  return value.toString();\n}\n\nexport function deserializePrimitive(value: string): string | number | boolean {\n  if (value === \"true\") {\n    return true;\n  } else if (value === \"false\") {\n    return false;\n  } else if (isInteger(value)) {\n    return parseInt(value, 10);\n  } else if (isFloat(value)) {\n    return parseFloat(value);\n  } else {\n    return value;\n  }\n}\n\nexport function dotify(\n  obj: Object,\n  prefix: string = \"\",\n  newobj: Object = {}\n): { [string]: string } {\n  prefix = prefix ? `${prefix}.` : prefix;\n  for (const key in obj) {\n    if (\n      !obj.hasOwnProperty(key) ||\n      obj[key] === undefined ||\n      obj[key] === null ||\n      typeof obj[key] === \"function\"\n    ) {\n      continue;\n    } else if (\n      obj[key] &&\n      Array.isArray(obj[key]) &&\n      obj[key].length &&\n      obj[key].every((val) => typeof val !== \"object\")\n    ) {\n      newobj[`${prefix}${key}[]`] = obj[key].join(\",\");\n    } else if (obj[key] && typeof obj[key] === \"object\") {\n      newobj = dotify(obj[key], `${prefix}${key}`, newobj);\n    } else {\n      newobj[`${prefix}${key}`] = serializePrimitive(obj[key]);\n    }\n  }\n  return newobj;\n}\n\nexport function undotify(obj: { [string]: string }): Object {\n  const result = {};\n\n  for (let key in obj) {\n    if (!obj.hasOwnProperty(key) || typeof obj[key] !== \"string\") {\n      continue;\n    }\n\n    let value = obj[key];\n\n    if (key.match(/^.+\\[\\]$/)) {\n      key = key.slice(0, -2);\n      value = value.split(\",\").map(deserializePrimitive);\n    } else {\n      value = deserializePrimitive(value);\n    }\n\n    let keyResult = result;\n    const parts = key.split(\".\");\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      const isLast = i + 1 === parts.length;\n      const isIndex = !isLast && isInteger(parts[i + 1]);\n\n      if (\n        part === \"constructor\" ||\n        part === \"prototype\" ||\n        part === \"__proto__\"\n      ) {\n        throw new Error(`Disallowed key: ${part}`);\n      }\n\n      if (isLast) {\n        // $FlowFixMe\n        keyResult[part] = value;\n      } else {\n        // $FlowFixMe\n        keyResult = keyResult[part] = keyResult[part] || (isIndex ? [] : {});\n      }\n    }\n  }\n\n  return result;\n}\n\nexport type EventEmitterType = {|\n  on: (eventName: string, handler: Function) => CancelableType,\n  once: (eventName: string, handler: Function) => CancelableType,\n  trigger: (\n    eventName: string,\n    ...args: $ReadOnlyArray<mixed>\n  ) => ZalgoPromise<void>,\n  triggerOnce: (\n    eventName: string,\n    ...args: $ReadOnlyArray<mixed>\n  ) => ZalgoPromise<void>,\n  reset: () => void,\n|};\n\nexport function eventEmitter(): EventEmitterType {\n  const triggered = {};\n  let handlers = {};\n\n  const emitter = {\n    on(eventName: string, handler: Function): CancelableType {\n      const handlerList = (handlers[eventName] = handlers[eventName] || []);\n\n      handlerList.push(handler);\n\n      let cancelled = false;\n\n      return {\n        cancel() {\n          if (!cancelled) {\n            cancelled = true;\n            handlerList.splice(handlerList.indexOf(handler), 1);\n          }\n        },\n      };\n    },\n\n    once(eventName: string, handler: Function): CancelableType {\n      const listener = emitter.on(eventName, () => {\n        listener.cancel();\n        handler();\n      });\n\n      return listener;\n    },\n\n    trigger(\n      eventName: string,\n      ...args: $ReadOnlyArray<mixed>\n    ): ZalgoPromise<void> {\n      const handlerList = handlers[eventName];\n      const promises = [];\n\n      if (handlerList) {\n        for (const handler of handlerList) {\n          promises.push(ZalgoPromise.try(() => handler(...args)));\n        }\n      }\n\n      return ZalgoPromise.all(promises).then(noop);\n    },\n\n    triggerOnce(\n      eventName: string,\n      ...args: $ReadOnlyArray<mixed>\n    ): ZalgoPromise<void> {\n      if (triggered[eventName]) {\n        return ZalgoPromise.resolve();\n      }\n\n      triggered[eventName] = true;\n      return emitter.trigger(eventName, ...args);\n    },\n\n    reset() {\n      handlers = {};\n    },\n  };\n\n  return emitter;\n}\n\nexport function camelToDasherize(string: string): string {\n  return string.replace(/([A-Z])/g, (g) => {\n    return `-${g.toLowerCase()}`;\n  });\n}\n\nexport function dasherizeToCamel(string: string): string {\n  return string.replace(/-([a-z])/g, (g) => {\n    return g[1].toUpperCase();\n  });\n}\n\nexport function capitalizeFirstLetter(string: string): string {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n}\n\nexport function get(item: Object, path: string, def: mixed): mixed {\n  if (!path) {\n    return def;\n  }\n\n  const pathParts = path.split(\".\");\n\n  // Loop through each section of our key path\n\n  for (let i = 0; i < pathParts.length; i++) {\n    // If we have an object, we can get the key\n    if (typeof item === \"object\" && item !== null) {\n      item = item[pathParts[i]];\n\n      // Otherwise, we should return the default (undefined if not provided)\n    } else {\n      return def;\n    }\n  }\n\n  // If our final result is undefined, we should return the default\n\n  return item === undefined ? def : item;\n}\n\nexport function safeTimeout(method: Function, time: number) {\n  const interval = safeInterval(() => {\n    time -= 100;\n    if (time <= 0) {\n      interval.cancel();\n      method();\n    }\n  }, 100);\n}\n\nexport function defineLazyProp<T>(\n  obj: Object | $ReadOnlyArray<mixed>,\n  key: string | number,\n  getter: () => T\n) {\n  if (Array.isArray(obj)) {\n    if (typeof key !== \"number\") {\n      throw new TypeError(`Array key must be number`);\n    }\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (typeof key !== \"string\") {\n      throw new TypeError(`Object key must be string`);\n    }\n  }\n\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: true,\n    get: () => {\n      // $FlowFixMe\n      delete obj[key];\n      const value = getter();\n      // $FlowFixMe\n      obj[key] = value;\n      return value;\n    },\n    set: (value: T) => {\n      // $FlowFixMe\n      delete obj[key];\n      // $FlowFixMe\n      obj[key] = value;\n    },\n  });\n}\n\n// eslint-disable-next-line no-undef\nexport function arrayFrom<T>(item: Iterable<T>): $ReadOnlyArray<T> {\n  // $FlowFixMe[method-unbinding]\n  return Array.prototype.slice.call(item);\n}\n\nexport function isObject(item: mixed): boolean {\n  return typeof item === \"object\" && item !== null;\n}\n\nexport function isObjectObject(obj: mixed): boolean {\n  return (\n    // $FlowFixMe[method-unbinding]\n    isObject(obj) && Object.prototype.toString.call(obj) === \"[object Object]\"\n  );\n}\n\nexport function isPlainObject(obj: mixed): boolean {\n  if (!isObjectObject(obj)) {\n    return false;\n  }\n\n  // $FlowFixMe\n  const constructor = obj.constructor;\n\n  if (typeof constructor !== \"function\") {\n    return false;\n  }\n\n  const prototype = constructor.prototype;\n\n  if (!isObjectObject(prototype)) {\n    return false;\n  }\n\n  if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function replaceObject<T: $ReadOnlyArray<mixed> | Object>(\n  item: T,\n  replacer: (mixed, string | number, string) => mixed,\n  fullKey: string = \"\"\n): T {\n  if (Array.isArray(item)) {\n    const length = item.length;\n    const result: Array<mixed> = [];\n\n    for (let i = 0; i < length; i++) {\n      defineLazyProp(result, i, () => {\n        const itemKey = fullKey ? `${fullKey}.${i}` : `${i}`;\n        const el = item[i];\n\n        let child = replacer(el, i, itemKey);\n\n        if (isPlainObject(child) || Array.isArray(child)) {\n          // $FlowFixMe\n          child = replaceObject(child, replacer, itemKey);\n        }\n\n        return child;\n      });\n    }\n\n    // $FlowFixMe\n    return result;\n  } else if (isPlainObject(item)) {\n    const result = {};\n\n    for (const key in item) {\n      if (!item.hasOwnProperty(key)) {\n        continue;\n      }\n\n      defineLazyProp(result, key, () => {\n        const itemKey = fullKey ? `${fullKey}.${key}` : `${key}`;\n        // $FlowFixMe\n        const el = item[key];\n\n        let child = replacer(el, key, itemKey);\n\n        if (isPlainObject(child) || Array.isArray(child)) {\n          // $FlowFixMe\n          child = replaceObject(child, replacer, itemKey);\n        }\n\n        return child;\n      });\n    }\n\n    // $FlowFixMe\n    return result;\n  } else {\n    throw new Error(`Pass an object or array`);\n  }\n}\n\nexport function copyProp(\n  source: Object,\n  target: Object,\n  name: string,\n  def: mixed\n) {\n  if (source.hasOwnProperty(name)) {\n    const descriptor = Object.getOwnPropertyDescriptor(source, name);\n    // $FlowFixMe\n    Object.defineProperty(target, name, descriptor);\n  } else {\n    target[name] = def;\n  }\n}\n\ntype RegexResultType = {|\n  text: string,\n  groups: $ReadOnlyArray<string>,\n  start: number,\n  end: number,\n  length: number,\n  replace: (text: string) => string,\n|};\n\nexport function regex(\n  pattern: string | RegExp,\n  string: string,\n  start: number = 0\n): ?RegexResultType {\n  if (typeof pattern === \"string\") {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    pattern = new RegExp(pattern);\n  }\n\n  const result = string.slice(start).match(pattern);\n\n  if (!result) {\n    return;\n  }\n\n  // $FlowFixMe\n  const index: number = result.index;\n  const regmatch = result[0];\n\n  return {\n    text: regmatch,\n    groups: result.slice(1),\n    start: start + index,\n    end: start + index + regmatch.length,\n    length: regmatch.length,\n\n    replace(text: string): string {\n      if (!regmatch) {\n        return \"\";\n      }\n\n      return `${regmatch.slice(0, start + index)}${text}${regmatch.slice(\n        index + regmatch.length\n      )}`;\n    },\n  };\n}\n\nexport function regexAll(\n  pattern: string | RegExp,\n  string: string\n): $ReadOnlyArray<RegexResultType> {\n  const matches = [];\n  let start = 0;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const regmatch = regex(pattern, string, start);\n\n    if (!regmatch) {\n      break;\n    }\n\n    matches.push(regmatch);\n    start = match.end;\n  }\n\n  return matches;\n}\n\nexport function isDefined(value: ?mixed): boolean {\n  return value !== null && value !== undefined;\n}\n\nexport function cycle(method: Function): ZalgoPromise<void> {\n  return ZalgoPromise.try(method).then(() => cycle(method));\n}\n\nexport function debounce<T>(\n  method: (...args: $ReadOnlyArray<mixed>) => T,\n  time: number = 100\n): (...args: $ReadOnlyArray<mixed>) => void {\n  let timeout;\n\n  const debounceWrapper = function () {\n    clearTimeout(timeout);\n\n    timeout = setTimeout(() => {\n      return method.apply(this, arguments);\n    }, time);\n  };\n\n  return setFunctionName(\n    debounceWrapper,\n    `${getFunctionName(method)}::debounced`\n  );\n}\n\nexport function isRegex(item: mixed): boolean {\n  // $FlowFixMe[method-unbinding]\n  return Object.prototype.toString.call(item) === \"[object RegExp]\";\n}\n\ntype FunctionProxy<T: Function> = (method: T) => T;\n\nexport const weakMapMemoize: FunctionProxy<*> = <R: mixed>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (arg: any) => R\n  // eslint-disable-next-line flowtype/no-weak-types\n): ((...args: $ReadOnlyArray<any>) => R) => {\n  const weakmap = new WeakMap();\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  return function weakmapMemoized(arg: any): R {\n    return weakmap.getOrSet(arg, () => method.call(this, arg));\n  };\n};\n\ntype FunctionPromiseProxy<\n  R: mixed,\n  T: (...args: $ReadOnlyArray<mixed>) => ZalgoPromise<R>\n> = (T) => T;\n\nexport const weakMapMemoizePromise: FunctionPromiseProxy<*, *> = <R: mixed>(\n  // eslint-disable-next-line flowtype/no-weak-types\n  method: (arg: any) => ZalgoPromise<R>\n  // eslint-disable-next-line flowtype/no-weak-types\n): ((...args: $ReadOnlyArray<any>) => ZalgoPromise<R>) => {\n  const weakmap = new WeakMap();\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  return function weakmapMemoizedPromise(arg: any): ZalgoPromise<R> {\n    return weakmap.getOrSet(arg, () =>\n      method.call(this, arg).finally(() => {\n        weakmap.delete(arg);\n      })\n    );\n  };\n};\n\nexport function getOrSet<O: Object, T: mixed>(\n  obj: O,\n  key: string,\n  getter: () => T\n): T {\n  if (obj.hasOwnProperty(key)) {\n    return obj[key];\n  }\n\n  const val = getter();\n  obj[key] = val;\n  return val;\n}\n\nexport type CleanupType = {|\n  set: <T: mixed>(string, T) => T, // eslint-disable-line no-undef\n  register: (Function) => {| cancel: () => void |},\n  all: (err?: mixed) => ZalgoPromise<void>,\n|};\n\nexport function cleanup(obj: Object): CleanupType {\n  const tasks = [];\n  let cleaned = false;\n  let cleanErr;\n\n  const cleaner = {\n    set<T: mixed>(name: string, item: T): T {\n      if (!cleaned) {\n        obj[name] = item;\n        cleaner.register(() => {\n          delete obj[name];\n        });\n      }\n      return item;\n    },\n\n    register(method: Function): {| cancel: () => void |} {\n      const task = once(() => method(cleanErr));\n\n      if (cleaned) {\n        method(cleanErr);\n      } else {\n        tasks.push(task);\n      }\n\n      return {\n        cancel: () => {\n          const index = tasks.indexOf(task);\n          if (index !== -1) {\n            tasks.splice(index, 1);\n          }\n        },\n      };\n    },\n\n    all(err?: mixed): ZalgoPromise<void> {\n      cleanErr = err;\n\n      const results = [];\n      cleaned = true;\n\n      while (tasks.length) {\n        const task = tasks.shift();\n        results.push(task());\n      }\n\n      return ZalgoPromise.all(results).then(noop);\n    },\n  };\n\n  return cleaner;\n}\n\nexport function tryCatch<T>(\n  fn: () => T\n): {| result: T, error: void |} | {| result: void, error: mixed |} {\n  let result;\n  let error;\n\n  try {\n    result = fn();\n  } catch (err) {\n    error = err;\n  }\n\n  // $FlowFixMe\n  return { result, error };\n}\n\n// eslint-disable-next-line flowtype/no-mutable-array\nexport function removeFromArray<X, T: Array<X>>(arr: T, item: X) {\n  const index = arr.indexOf(item);\n  if (index !== -1) {\n    arr.splice(index, 1);\n  }\n}\n\nexport function assertExists<T>(name: string, thing: void | null | T): T {\n  if (thing === null || typeof thing === \"undefined\") {\n    throw new Error(`Expected ${name} to be present`);\n  }\n\n  return thing;\n}\n\nexport function unique(arr: $ReadOnlyArray<string>): $ReadOnlyArray<string> {\n  const result = {};\n  for (const item of arr) {\n    result[item] = true;\n  }\n  return Object.keys(result);\n}\n\nexport const constHas = <X: string | boolean | number, T: { [string]: X }>(\n  constant: T,\n  value: X\n): boolean => {\n  return memoizedValues(constant).indexOf(value) !== -1;\n};\n\nexport function dedupeErrors<T>(handler: (mixed) => T): (mixed) => T | void {\n  const seenErrors = [];\n  const seenStringifiedErrors = {};\n\n  return (err) => {\n    if (seenErrors.indexOf(err) !== -1) {\n      return;\n    }\n\n    seenErrors.push(err);\n\n    const stringifiedError = stringifyError(err);\n    if (seenStringifiedErrors[stringifiedError]) {\n      return;\n    }\n\n    seenStringifiedErrors[stringifiedError] = true;\n    return handler(err);\n  };\n}\n\nexport class ExtendableError extends Error {\n  constructor(message: string) {\n    super(message);\n    // eslint-disable-next-line unicorn/custom-error-definition\n    this.name = this.constructor.name;\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      this.stack = new Error(message).stack;\n    }\n  }\n}\n\nfunction isRelativeUrlWithoutProtocol(url: string): boolean {\n  return relativeFirstCharacters.indexOf(url[0]) > -1;\n}\n\nfunction decodeHtmlCharacters(str: string): string {\n  const removedNullByte: string = str.replace(ctrlCharactersRegex, \"\");\n  return removedNullByte.replace(htmlEntitiesRegex, (matchRegex, dec) => {\n    return String.fromCharCode(dec);\n  });\n}\n\nexport function sanitizeUrl(url?: string): string {\n  if (!url) {\n    return BLANK_URL;\n  }\n\n  const sanitizedUrl = decodeHtmlCharacters(url)\n    .replace(htmlCtrlEntityRegex, \"\")\n    .replace(ctrlCharactersRegex, \"\")\n    .trim();\n\n  if (!sanitizedUrl) {\n    return BLANK_URL;\n  }\n\n  if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {\n    return sanitizedUrl;\n  }\n\n  const urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);\n\n  if (!urlSchemeParseResults) {\n    return sanitizedUrl;\n  }\n\n  const urlScheme = urlSchemeParseResults[0];\n\n  if (invalidProtocolRegex.test(urlScheme)) {\n    return BLANK_URL;\n  }\n\n  return sanitizedUrl;\n}\n","/* @flow */\n\nexport function hasNativeWeakMap() : boolean {\n\n    if (typeof WeakMap === 'undefined') {\n        return false;\n    }\n\n    if (typeof Object.freeze === 'undefined') {\n        return false;\n    }\n\n    try {\n\n        const testWeakMap = new WeakMap();\n        const testKey = {};\n        const testValue = '__testvalue__';\n\n        Object.freeze(testKey);\n\n        testWeakMap.set(testKey, testValue);\n\n        if (testWeakMap.get(testKey) === testValue) {\n            return true;\n        }\n\n        return false;\n\n    } catch (err) {\n\n        return false;\n    }\n}\n","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nimport isNativeFunction from \"@babel/runtime/helpers/esm/isNativeFunction\";\nimport construct from \"@babel/runtime/helpers/esm/construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","/* @flow */\n/* eslint max-lines: off */\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  linkFrameWindow,\n  isWindowClosed,\n  assertSameDomain,\n  type SameDomainWindowType,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\nimport { WeakMap } from \"@krakenjs/cross-domain-safe-weakmap/src\";\n\nimport {\n  isElement,\n  inlineMemoize,\n  memoize,\n  noop,\n  stringify,\n  capitalizeFirstLetter,\n  once,\n  extend,\n  safeInterval,\n  uniqueID,\n  arrayFrom,\n  ExtendableError,\n  strHashStr,\n} from \"./util\";\nimport { isDevice } from \"./device\";\nimport { KEY_CODES, ATTRIBUTES, UID_HASH_LENGTH } from \"./constants\";\nimport type { CancelableType } from \"./types\";\n\ntype ElementRefType = string | HTMLElement;\n\nexport function getBody(): HTMLBodyElement {\n  // eslint-disable-next-line compat/compat\n  const body = document.body;\n\n  if (!body) {\n    throw new Error(`Body element not found`);\n  }\n\n  return body;\n}\n\nexport function isDocumentReady(): boolean {\n  // eslint-disable-next-line compat/compat\n  return Boolean(document.body) && document.readyState === \"complete\";\n}\n\nexport function isDocumentInteractive(): boolean {\n  // eslint-disable-next-line compat/compat\n  return Boolean(document.body) && document.readyState === \"interactive\";\n}\n\nexport function urlEncode(str: string): string {\n  return encodeURIComponent(str);\n}\n\nexport function waitForWindowReady(): ZalgoPromise<void> {\n  return inlineMemoize(waitForWindowReady, (): ZalgoPromise<void> => {\n    return new ZalgoPromise((resolve) => {\n      if (isDocumentReady()) {\n        resolve();\n      }\n\n      window.addEventListener(\"load\", () => resolve());\n    });\n  });\n}\n\ntype WaitForDocumentReady = () => ZalgoPromise<void>;\n\nexport const waitForDocumentReady: WaitForDocumentReady = memoize(() => {\n  return new ZalgoPromise((resolve) => {\n    if (isDocumentReady() || isDocumentInteractive()) {\n      return resolve();\n    }\n\n    const interval = setInterval(() => {\n      if (isDocumentReady() || isDocumentInteractive()) {\n        clearInterval(interval);\n        return resolve();\n      }\n    }, 10);\n  });\n});\n\nexport function waitForDocumentBody(): ZalgoPromise<HTMLBodyElement> {\n  return ZalgoPromise.try(() => {\n    if (document.body) {\n      return document.body;\n    }\n\n    return waitForDocumentReady().then(() => {\n      if (document.body) {\n        return document.body;\n      }\n\n      throw new Error(\"Document ready but document.body not present\");\n    });\n  });\n}\n\nexport function parseQuery(queryString: string): Object {\n  return inlineMemoize(\n    parseQuery,\n    (): Object => {\n      const params = {};\n\n      if (!queryString) {\n        return params;\n      }\n\n      if (queryString.indexOf(\"=\") === -1) {\n        return params;\n      }\n\n      for (let pair of queryString.split(\"&\")) {\n        pair = pair.split(\"=\");\n\n        if (pair[0] && pair[1]) {\n          params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n      }\n\n      return params;\n    },\n    [queryString]\n  );\n}\n\nexport function getQueryParam(name: string): string {\n  return parseQuery(window.location.search.slice(1))[name];\n}\n\nexport function urlWillRedirectPage(url: string): boolean {\n  if (url.indexOf(\"#\") === -1) {\n    return true;\n  }\n\n  if (url.indexOf(\"#\") === 0) {\n    return false;\n  }\n\n  if (url.split(\"#\")[0] === window.location.href.split(\"#\")[0]) {\n    return false;\n  }\n\n  return true;\n}\n\nexport type Query = {\n  [string]: boolean | string,\n};\n\nexport function formatQuery(obj: Query = {}): string {\n  return Object.keys(obj)\n    .filter((key) => {\n      return typeof obj[key] === \"string\" || typeof obj[key] === \"boolean\";\n    })\n    .map((key) => {\n      const val = obj[key];\n\n      if (typeof val !== \"string\" && typeof val !== \"boolean\") {\n        throw new TypeError(`Invalid type for query`);\n      }\n\n      return `${urlEncode(key)}=${urlEncode(val.toString())}`;\n    })\n    .join(\"&\");\n}\n\nexport function extendQuery(originalQuery: string, props: Query = {}): string {\n  if (!props || !Object.keys(props).length) {\n    return originalQuery;\n  }\n\n  return formatQuery({\n    ...parseQuery(originalQuery),\n    ...props,\n  });\n}\n\nexport function extendUrl(\n  url: string,\n  options: {| query?: Query, hash?: Query |}\n): string {\n  const query = options.query || {};\n  const hash = options.hash || {};\n\n  let originalUrl;\n  let originalQuery;\n  let originalHash;\n\n  [originalUrl, originalHash] = url.split(\"#\");\n  [originalUrl, originalQuery] = originalUrl.split(\"?\");\n\n  const queryString = extendQuery(originalQuery, query);\n  const hashString = extendQuery(originalHash, hash);\n\n  if (queryString) {\n    originalUrl = `${originalUrl}?${queryString}`;\n  }\n\n  if (hashString) {\n    originalUrl = `${originalUrl}#${hashString}`;\n  }\n\n  return originalUrl;\n}\n\nexport function redirect(\n  url: string,\n  win: CrossDomainWindowType = window\n): ZalgoPromise<void> {\n  return new ZalgoPromise((resolve) => {\n    win.location = url;\n    if (!urlWillRedirectPage(url)) {\n      resolve();\n    }\n  });\n}\n\nexport function hasMetaViewPort(): boolean {\n  const meta = document.querySelector(\"meta[name=viewport]\");\n\n  if (isDevice() && window.screen.width < 660 && !meta) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function isElementVisible(el: HTMLElement): boolean {\n  return Boolean(\n    el.offsetWidth || el.offsetHeight || el.getClientRects().length\n  );\n}\n\nexport function getPerformance(): ?Performance {\n  return inlineMemoize(getPerformance, (): ?Performance => {\n    const performance = window.performance;\n\n    if (\n      performance &&\n      performance.now &&\n      performance.timing &&\n      performance.timing.connectEnd &&\n      performance.timing.navigationStart &&\n      Math.abs(performance.now() - Date.now()) > 1000 &&\n      performance.now() -\n        (performance.timing.connectEnd - performance.timing.navigationStart) >\n        0\n    ) {\n      return performance;\n    }\n  });\n}\n\nexport function enablePerformance(): boolean {\n  return Boolean(getPerformance());\n}\n\nexport function getPageRenderTime(): ZalgoPromise<?number> {\n  return waitForDocumentReady().then(() => {\n    const performance = getPerformance();\n\n    if (!performance) {\n      return;\n    }\n\n    const timing = performance.timing;\n\n    if (timing.connectEnd && timing.domInteractive) {\n      return timing.domInteractive - timing.connectEnd;\n    }\n  });\n}\n\nexport function htmlEncode(html: string = \"\"): string {\n  return html\n    .toString()\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\")\n    .replace(/\\//g, \"&#x2F;\");\n}\n\nexport function isBrowser(): boolean {\n  return typeof window !== \"undefined\" && window.location !== undefined;\n}\n\nexport function querySelectorAll(\n  selector: string,\n  doc: HTMLElement = window.document\n): $ReadOnlyArray<HTMLElement> {\n  // $FlowFixMe[method-unbinding]\n  return Array.prototype.slice.call(doc.querySelectorAll(selector));\n}\n\n/**\n * Sets up event handlers for click events and\n * enter/space keypresses.\n * @callback handler\n * @param {HTMLElement} element\n * @param {handler} handler\n */\nexport function onClick(element: HTMLElement, handler: (Event) => void) {\n  element.addEventListener(\"touchstart\", noop, { passive: true });\n  element.addEventListener(\"click\", handler);\n  element.addEventListener(\"keypress\", (event: Event) => {\n    if (\n      // $FlowFixMe\n      event.keyCode === KEY_CODES.ENTER ||\n      // $FlowFixMe\n      event.keyCode === KEY_CODES.SPACE\n    ) {\n      return handler(event);\n    }\n  });\n}\n\nexport function getScript({\n  host = window.location.host,\n  path,\n  reverse = false,\n}: {|\n  host?: string,\n  path: string,\n  reverse?: boolean,\n|}): ?HTMLScriptElement {\n  return inlineMemoize(\n    getScript,\n    (): ?HTMLScriptElement => {\n      const url = `${host}${path}`;\n      // $FlowFixMe[method-unbinding]\n      const scripts = Array.prototype.slice.call(\n        document.getElementsByTagName(\"script\")\n      );\n\n      if (reverse) {\n        scripts.reverse();\n      }\n\n      for (const script of scripts) {\n        if (!script.src) {\n          continue;\n        }\n\n        const src = script.src.replace(/^https?:\\/\\//, \"\").split(\"?\")[0];\n\n        if (src === url) {\n          return script;\n        }\n      }\n    },\n    [path]\n  );\n}\n\nexport function isLocalStorageEnabled(): boolean {\n  return inlineMemoize(isLocalStorageEnabled, () => {\n    try {\n      if (typeof window === \"undefined\") {\n        return false;\n      }\n\n      if (window.localStorage) {\n        const value = Math.random().toString();\n        window.localStorage.setItem(\"__test__localStorage__\", value);\n        const result = window.localStorage.getItem(\"__test__localStorage__\");\n        window.localStorage.removeItem(\"__test__localStorage__\");\n        if (value === result) {\n          return true;\n        }\n      }\n    } catch (err) {\n      // pass\n    }\n    return false;\n  });\n}\n\nexport function getBrowserLocales(): $ReadOnlyArray<{|\n  country?: string,\n  lang: string,\n|}> {\n  const nav = window.navigator;\n\n  const locales = nav.languages ? [...nav.languages] : [];\n\n  if (nav.language) {\n    locales.push(nav.language);\n  }\n\n  if (nav.userLanguage) {\n    locales.push(nav.userLanguage);\n  }\n\n  return locales\n    .map((locale) => {\n      if (locale && locale.match(/^[a-z]{2}[-_][A-Z]{2}$/)) {\n        const [lang, country] = locale.split(/[-_]/);\n        return { country, lang };\n      }\n\n      if (locale && locale.match(/^[a-z]{2}$/)) {\n        return { lang: locale };\n      }\n\n      return null;\n    })\n    .filter(Boolean);\n}\n\nexport function appendChild(container: HTMLElement, child: HTMLElement | Text) {\n  container.appendChild(child);\n}\n\nexport function getElementSafe(\n  id: ElementRefType,\n  doc: Document | HTMLElement = document\n): ?HTMLElement {\n  if (isElement(id)) {\n    // $FlowFixMe\n    return id;\n  }\n\n  if (typeof id === \"string\") {\n    return doc.querySelector(id);\n  }\n}\n\nexport function getElement(\n  id: ElementRefType,\n  doc: Document | HTMLElement = document\n): HTMLElement {\n  const element = getElementSafe(id, doc);\n\n  if (element) {\n    return element;\n  }\n\n  throw new Error(`Can not find element: ${stringify(id)}`);\n}\n\nexport function elementReady(id: ElementRefType): ZalgoPromise<HTMLElement> {\n  return new ZalgoPromise((resolve, reject) => {\n    const name = stringify(id);\n    let el = getElementSafe(id);\n\n    if (el) {\n      return resolve(el);\n    }\n\n    if (isDocumentReady()) {\n      return reject(\n        new Error(`Document is ready and element ${name} does not exist`)\n      );\n    }\n\n    const interval = setInterval(() => {\n      el = getElementSafe(id);\n\n      if (el) {\n        resolve(el);\n        clearInterval(interval);\n        return;\n      }\n\n      if (isDocumentReady()) {\n        clearInterval(interval);\n        return reject(\n          new Error(`Document is ready and element ${name} does not exist`)\n        );\n      }\n    }, 10);\n  });\n}\n\n// eslint-disable-next-line unicorn/custom-error-definition\nexport class PopupOpenError extends ExtendableError {}\n\ntype PopupOptions = {|\n  name?: string,\n  width?: number,\n  height?: number,\n  top?: number,\n  left?: number,\n  status?: 0 | 1,\n  resizable?: 0 | 1,\n  toolbar?: 0 | 1,\n  menubar?: 0 | 1,\n  scrollbars?: 0 | 1,\n  closeOnUnload?: 0 | 1,\n|};\n\nexport function popup(\n  url: string,\n  options?: PopupOptions\n): CrossDomainWindowType {\n  // $FlowFixMe\n  options = options || {};\n\n  const { closeOnUnload = 1, name = \"\", width, height } = options;\n\n  let top = 0;\n  let left = 0;\n\n  if (width) {\n    if (window.outerWidth) {\n      left = Math.round((window.outerWidth - width) / 2) + window.screenX;\n    } else if (window.screen.width) {\n      left = Math.round((window.screen.width - width) / 2);\n    }\n  }\n\n  if (height) {\n    if (window.outerHeight) {\n      top = Math.round((window.outerHeight - height) / 2) + window.screenY;\n    } else if (window.screen.height) {\n      top = Math.round((window.screen.height - height) / 2);\n    }\n  }\n\n  delete options.closeOnUnload;\n  delete options.name;\n\n  if (width && height) {\n    // $FlowFixMe\n    options = {\n      top,\n      left,\n      width,\n      height,\n      status: 1,\n      toolbar: 0,\n      menubar: 0,\n      resizable: 1,\n      scrollbars: 1,\n      ...options,\n    };\n  }\n\n  const params = Object.keys(options)\n    // eslint-disable-next-line array-callback-return\n    .map((key) => {\n      // $FlowFixMe\n      if (options[key] !== null && options[key] !== undefined) {\n        return `${key}=${stringify(options[key])}`;\n      }\n    })\n    .filter(Boolean)\n    .join(\",\");\n\n  let win;\n\n  try {\n    win = window.open(url, name, params);\n  } catch (err) {\n    throw new PopupOpenError(\n      `Can not open popup window - ${err.stack || err.message}`\n    );\n  }\n\n  if (isWindowClosed(win)) {\n    const err = new PopupOpenError(`Can not open popup window - blocked`);\n    throw err;\n  }\n\n  if (closeOnUnload) {\n    window.addEventListener(\"unload\", () => win.close());\n  }\n\n  return win;\n}\n\nexport function writeToWindow(win: SameDomainWindowType, html: string) {\n  try {\n    win.document.open();\n    win.document.write(html);\n    win.document.close();\n  } catch (err) {\n    try {\n      win.location = `javascript: document.open(); document.write(${JSON.stringify(\n        html\n      )}); document.close();`;\n    } catch (err2) {\n      // pass\n    }\n  }\n}\n\nexport function writeElementToWindow(\n  win: SameDomainWindowType,\n  el: HTMLElement\n) {\n  const tag = el.tagName.toLowerCase();\n\n  if (tag !== \"html\") {\n    throw new Error(`Expected element to be html, got ${tag}`);\n  }\n\n  const documentElement = win.document.documentElement;\n\n  for (const child of arrayFrom(documentElement.children)) {\n    documentElement.removeChild(child);\n  }\n\n  for (const child of arrayFrom(el.children)) {\n    documentElement.appendChild(child);\n  }\n}\n\nexport function setStyle(\n  el: HTMLElement,\n  styleText: string,\n  doc: Document = window.document\n) {\n  // $FlowFixMe\n  if (el.styleSheet) {\n    // $FlowFixMe\n    el.styleSheet.cssText = styleText;\n  } else {\n    el.appendChild(doc.createTextNode(styleText));\n  }\n}\n\nexport type ElementOptionsType = {|\n  style?: { [string]: string },\n  id?: string,\n  class?: ?$ReadOnlyArray<string>,\n  attributes?: { [string]: string },\n  styleSheet?: ?string,\n  html?: ?string,\n|};\n\nlet awaitFrameLoadPromises: WeakMap<\n  HTMLIFrameElement,\n  ZalgoPromise<HTMLIFrameElement>\n>;\n\nexport function awaitFrameLoad(\n  frame: HTMLIFrameElement\n): ZalgoPromise<HTMLIFrameElement> {\n  awaitFrameLoadPromises = awaitFrameLoadPromises || new WeakMap();\n\n  if (awaitFrameLoadPromises.has(frame)) {\n    const promise = awaitFrameLoadPromises.get(frame);\n    if (promise) {\n      return promise;\n    }\n  }\n\n  const promise = new ZalgoPromise((resolve, reject) => {\n    frame.addEventListener(\"load\", () => {\n      linkFrameWindow(frame);\n      resolve(frame);\n    });\n\n    frame.addEventListener(\"error\", (err: Event) => {\n      if (frame.contentWindow) {\n        resolve(frame);\n      } else {\n        reject(err);\n      }\n    });\n  });\n\n  awaitFrameLoadPromises.set(frame, promise);\n\n  return promise;\n}\n\nexport function awaitFrameWindow(\n  frame: HTMLIFrameElement\n): ZalgoPromise<CrossDomainWindowType> {\n  return awaitFrameLoad(frame).then((loadedFrame) => {\n    if (!loadedFrame.contentWindow) {\n      throw new Error(`Could not find window in iframe`);\n    }\n\n    return loadedFrame.contentWindow;\n  });\n}\n\nconst getDefaultCreateElementOptions = (): ElementOptionsType => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function createElement(\n  tag: string = \"div\",\n  options: ElementOptionsType = getDefaultCreateElementOptions(),\n  container: ?HTMLElement\n): HTMLElement {\n  tag = tag.toLowerCase();\n  const element = document.createElement(tag);\n\n  if (options.style) {\n    extend(element.style, options.style);\n  }\n\n  if (options.class) {\n    element.className = options.class.join(\" \");\n  }\n\n  if (options.id) {\n    element.setAttribute(\"id\", options.id);\n  }\n\n  if (options.attributes) {\n    for (const key of Object.keys(options.attributes)) {\n      element.setAttribute(key, options.attributes[key]);\n    }\n  }\n\n  if (options.styleSheet) {\n    setStyle(element, options.styleSheet);\n  }\n\n  if (container) {\n    appendChild(container, element);\n  }\n\n  if (options.html) {\n    if (tag === \"iframe\") {\n      // $FlowFixMe\n      if (!container || !element.contentWindow) {\n        throw new Error(\n          `Iframe html can not be written unless container provided and iframe in DOM`\n        );\n      }\n\n      // $FlowFixMe\n      writeToWindow(element.contentWindow, options.html);\n    } else {\n      element.innerHTML = options.html;\n    }\n  }\n\n  return element;\n}\n\ntype StringMap = {|\n  [string]: string,\n|};\n\nexport type IframeElementOptionsType = {|\n  style?: StringMap,\n  class?: ?$ReadOnlyArray<string>,\n  attributes?: StringMap,\n  styleSheet?: ?string,\n  html?: ?string,\n  url?: ?string,\n|};\n\nconst getDefaultIframeOptions = (): IframeElementOptionsType => {\n  // $FlowFixMe\n  return {};\n};\n\nconst getDefaultStringMap = (): StringMap => {\n  // $FlowFixMe\n  return {};\n};\n\nexport function iframe(\n  options: IframeElementOptionsType = getDefaultIframeOptions(),\n  container: ?HTMLElement\n): HTMLIFrameElement {\n  const attributes = options.attributes || getDefaultStringMap();\n  const style = options.style || getDefaultStringMap();\n\n  // $FlowFixMe\n  const newAttributes = {\n    allowTransparency: \"true\",\n    ...attributes,\n  };\n\n  // $FlowFixMe\n  const newStyle = {\n    backgroundColor: \"transparent\",\n    border: \"none\",\n    ...style,\n  };\n\n  const frame = createElement(\"iframe\", {\n    attributes: newAttributes,\n    style: newStyle,\n    html: options.html,\n    class: options.class,\n  });\n\n  const isIE = window.navigator.userAgent.match(/MSIE|Edge/i);\n\n  if (!frame.hasAttribute(\"id\")) {\n    frame.setAttribute(\"id\", uniqueID());\n  }\n\n  // $FlowFixMe\n  awaitFrameLoad(frame);\n\n  if (container) {\n    const el = getElement(container);\n    el.appendChild(frame);\n  }\n\n  if (options.url || isIE) {\n    frame.setAttribute(\"src\", options.url || \"about:blank\");\n  }\n\n  // $FlowFixMe\n  return frame;\n}\n\nexport function addEventListener(\n  obj: HTMLElement,\n  event: string,\n  handler: (event: Event) => void\n): CancelableType {\n  obj.addEventListener(event, handler);\n  return {\n    cancel() {\n      obj.removeEventListener(event, handler);\n    },\n  };\n}\n\nexport function bindEvents(\n  element: HTMLElement,\n  eventNames: $ReadOnlyArray<string>,\n  handler: (event: Event) => void\n): CancelableType {\n  handler = once(handler);\n\n  for (const eventName of eventNames) {\n    element.addEventListener(eventName, handler);\n  }\n\n  return {\n    cancel: once(() => {\n      for (const eventName of eventNames) {\n        element.removeEventListener(eventName, handler);\n      }\n    }),\n  };\n}\n\nconst VENDOR_PREFIXES = [\"webkit\", \"moz\", \"ms\", \"o\"];\n\nexport function setVendorCSS(\n  element: HTMLElement,\n  name: string,\n  value: string\n) {\n  // $FlowFixMe\n  element.style[name] = value;\n\n  const capitalizedName = capitalizeFirstLetter(name);\n\n  for (const prefix of VENDOR_PREFIXES) {\n    // $FlowFixMe\n    element.style[`${prefix}${capitalizedName}`] = value;\n  }\n}\n\nconst ANIMATION_START_EVENTS = [\n  \"animationstart\",\n  \"webkitAnimationStart\",\n  \"oAnimationStart\",\n  \"MSAnimationStart\",\n];\nconst ANIMATION_END_EVENTS = [\n  \"animationend\",\n  \"webkitAnimationEnd\",\n  \"oAnimationEnd\",\n  \"MSAnimationEnd\",\n];\n\nexport function animate(\n  element: ElementRefType,\n  name: string,\n  clean: (Function) => void,\n  timeout: number = 1000\n): ZalgoPromise<void> {\n  return new ZalgoPromise((resolve, reject) => {\n    const el = getElement(element);\n\n    if (!el) {\n      return resolve();\n    }\n\n    let hasStarted = false;\n\n    // eslint-disable-next-line prefer-const\n    let startTimeout;\n    let endTimeout;\n    // eslint-disable-next-line prefer-const\n    let startEvent;\n    // eslint-disable-next-line prefer-const\n    let endEvent;\n\n    function cleanUp() {\n      clearTimeout(startTimeout);\n      clearTimeout(endTimeout);\n      startEvent.cancel();\n      endEvent.cancel();\n    }\n\n    startEvent = bindEvents(el, ANIMATION_START_EVENTS, (event) => {\n      // $FlowFixMe\n      if (event.target !== el || event.animationName !== name) {\n        return;\n      }\n\n      clearTimeout(startTimeout);\n\n      event.stopPropagation();\n\n      startEvent.cancel();\n      hasStarted = true;\n\n      endTimeout = setTimeout(() => {\n        cleanUp();\n        resolve();\n      }, timeout);\n    });\n\n    endEvent = bindEvents(el, ANIMATION_END_EVENTS, (event) => {\n      // $FlowFixMe\n      if (event.target !== el || event.animationName !== name) {\n        return;\n      }\n\n      cleanUp();\n\n      if (\n        // $FlowFixMe\n        typeof event.animationName === \"string\" &&\n        event.animationName !== name\n      ) {\n        return reject(\n          `Expected animation name to be ${name}, found ${event.animationName}`\n        );\n      }\n\n      return resolve();\n    });\n\n    setVendorCSS(el, \"animationName\", name);\n\n    startTimeout = setTimeout(() => {\n      if (!hasStarted) {\n        cleanUp();\n        return resolve();\n      }\n    }, 200);\n\n    if (clean) {\n      clean(cleanUp);\n    }\n  });\n}\n\nexport function makeElementVisible(element: HTMLElement) {\n  element.style.setProperty(\"visibility\", \"\");\n}\n\nexport function makeElementInvisible(element: HTMLElement) {\n  element.style.setProperty(\"visibility\", \"hidden\", \"important\");\n}\n\nexport function showElement(element: HTMLElement) {\n  element.style.setProperty(\"display\", \"\");\n}\n\nexport function hideElement(element: HTMLElement) {\n  element.style.setProperty(\"display\", \"none\", \"important\");\n}\n\nexport function destroyElement(element: HTMLElement) {\n  if (element && element.parentNode) {\n    element.parentNode.removeChild(element);\n  }\n}\n\nexport function showAndAnimate(\n  element: HTMLElement,\n  name: string,\n  clean: (Function) => void\n): ZalgoPromise<void> {\n  const animation = animate(element, name, clean);\n  showElement(element);\n  return animation;\n}\n\nexport function animateAndHide(\n  element: HTMLElement,\n  name: string,\n  clean: (Function) => void\n): ZalgoPromise<void> {\n  return animate(element, name, clean).then(() => {\n    hideElement(element);\n  });\n}\n\nexport function addClass(element: HTMLElement, name: string) {\n  element.classList.add(name);\n}\n\nexport function removeClass(element: HTMLElement, name: string) {\n  element.classList.remove(name);\n}\n\nexport function isElementClosed(el: HTMLElement): boolean {\n  if (\n    !el ||\n    !el.parentNode ||\n    !el.ownerDocument ||\n    !el.ownerDocument.documentElement ||\n    !el.ownerDocument.documentElement.contains(el)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function watchElementForClose(\n  element: HTMLElement,\n  handler: () => mixed\n): CancelableType {\n  handler = once(handler);\n\n  let cancelled = false;\n  const mutationObservers = [];\n  // eslint-disable-next-line prefer-const\n  let interval;\n  // eslint-disable-next-line prefer-const\n  let sacrificialFrame;\n  let sacrificialFrameWin;\n\n  const cancel = () => {\n    cancelled = true;\n    for (const observer of mutationObservers) {\n      observer.disconnect();\n    }\n    if (interval) {\n      interval.cancel();\n    }\n    if (sacrificialFrameWin) {\n      // eslint-disable-next-line no-use-before-define\n      sacrificialFrameWin.removeEventListener(\"unload\", elementClosed);\n    }\n    if (sacrificialFrame) {\n      destroyElement(sacrificialFrame);\n    }\n  };\n\n  const elementClosed = () => {\n    if (!cancelled) {\n      handler();\n      cancel();\n    }\n  };\n\n  if (isElementClosed(element)) {\n    elementClosed();\n    return { cancel };\n  }\n\n  // Strategy 1: Mutation observer\n\n  if (window.MutationObserver) {\n    let mutationElement = element.parentElement;\n    while (mutationElement) {\n      const mutationObserver = new window.MutationObserver(() => {\n        if (isElementClosed(element)) {\n          elementClosed();\n        }\n      });\n\n      mutationObserver.observe(mutationElement, { childList: true });\n      mutationObservers.push(mutationObserver);\n      mutationElement = mutationElement.parentElement;\n    }\n  }\n\n  // Strategy 2: Sacrificial iframe\n\n  sacrificialFrame = document.createElement(\"iframe\");\n  sacrificialFrame.setAttribute(\"name\", `__detect_close_${uniqueID()}__`);\n  sacrificialFrame.style.display = \"none\";\n  awaitFrameWindow(sacrificialFrame).then((frameWin) => {\n    sacrificialFrameWin = assertSameDomain(frameWin);\n    sacrificialFrameWin.addEventListener(\"unload\", elementClosed);\n  });\n  element.appendChild(sacrificialFrame);\n\n  // Strategy 3: Poller\n\n  const check = () => {\n    if (isElementClosed(element)) {\n      elementClosed();\n    }\n  };\n  interval = safeInterval(check, 1000);\n\n  return { cancel };\n}\n\nexport function fixScripts(el: HTMLElement, doc: Document = window.document) {\n  for (const script of querySelectorAll(\"script\", el)) {\n    const parentNode = script.parentNode;\n\n    if (!parentNode) {\n      continue;\n    }\n\n    const newScript = doc.createElement(\"script\");\n    newScript.text = script.textContent;\n    parentNode.replaceChild(newScript, script);\n  }\n}\n\ntype OnResizeOptions = {|\n  width?: boolean,\n  height?: boolean,\n  interval?: number,\n  win?: SameDomainWindowType,\n|};\n\nexport function onResize(\n  el: HTMLElement,\n  handler: ({| width: number, height: number |}) => void,\n  {\n    width = true,\n    height = true,\n    interval = 100,\n    win = window,\n  }: OnResizeOptions = {}\n): {| cancel: () => void |} {\n  let currentWidth = el.offsetWidth;\n  let currentHeight = el.offsetHeight;\n  let canceled = false;\n\n  handler({ width: currentWidth, height: currentHeight });\n\n  const check = () => {\n    if (canceled || !isElementVisible(el)) {\n      return;\n    }\n\n    const newWidth = el.offsetWidth;\n    const newHeight = el.offsetHeight;\n\n    if (\n      (width && newWidth !== currentWidth) ||\n      (height && newHeight !== currentHeight)\n    ) {\n      handler({ width: newWidth, height: newHeight });\n    }\n\n    currentWidth = newWidth;\n    currentHeight = newHeight;\n  };\n\n  let observer;\n  let timeout;\n\n  win.addEventListener(\"resize\", check);\n\n  if (typeof win.ResizeObserver !== \"undefined\") {\n    observer = new win.ResizeObserver(check);\n    observer.observe(el);\n    timeout = safeInterval(check, interval * 10);\n  } else if (typeof win.MutationObserver !== \"undefined\") {\n    observer = new win.MutationObserver(check);\n    observer.observe(el, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: false,\n    });\n    timeout = safeInterval(check, interval * 10);\n  } else {\n    timeout = safeInterval(check, interval);\n  }\n\n  return {\n    cancel: () => {\n      canceled = true;\n      observer.disconnect();\n      window.removeEventListener(\"resize\", check);\n      timeout.cancel();\n    },\n  };\n}\n\nexport function getResourceLoadTime(url: string): ?number {\n  const performance = getPerformance();\n\n  if (!performance) {\n    return;\n  }\n\n  // $FlowFixMe[method-unbinding]\n  if (typeof performance.getEntries !== \"function\") {\n    return;\n  }\n\n  const entries = performance.getEntries();\n\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n\n    if (\n      entry &&\n      entry.name &&\n      entry.name.indexOf(url) === 0 &&\n      typeof entry.duration === \"number\"\n    ) {\n      return Math.floor(entry.duration);\n    }\n  }\n}\n\nexport function isShadowElement(element: Node): boolean {\n  while (element.parentNode) {\n    element = element.parentNode;\n  }\n\n  return element.toString() === \"[object ShadowRoot]\";\n}\n\nexport function getShadowRoot(element: Node): ?Node {\n  while (element.parentNode) {\n    element = element.parentNode;\n  }\n\n  if (isShadowElement(element)) {\n    return element;\n  }\n}\n\nexport function getShadowHost(element: Node): ?HTMLElement {\n  const shadowRoot = getShadowRoot(element);\n\n  // $FlowFixMe\n  if (shadowRoot && shadowRoot.host) {\n    // $FlowFixMe\n    return shadowRoot.host;\n  }\n}\n\nexport function insertShadowSlot(element: HTMLElement): HTMLElement {\n  const shadowHost = getShadowHost(element);\n\n  if (!shadowHost) {\n    throw new Error(`Element is not in shadow dom`);\n  }\n\n  const slotName = `shadow-slot-${uniqueID()}`;\n  const slot = document.createElement(\"slot\");\n  slot.setAttribute(\"name\", slotName);\n  element.appendChild(slot);\n\n  const slotProvider = document.createElement(\"div\");\n  slotProvider.setAttribute(\"slot\", slotName);\n  shadowHost.appendChild(slotProvider);\n\n  if (isShadowElement(shadowHost)) {\n    return insertShadowSlot(slotProvider);\n  }\n\n  return slotProvider;\n}\n\nexport function preventClickFocus(el: HTMLElement) {\n  const onFocus = (event: Event) => {\n    el.removeEventListener(\"focus\", onFocus);\n    event.preventDefault();\n    el.blur();\n    return false;\n  };\n\n  el.addEventListener(\"mousedown\", () => {\n    el.addEventListener(\"focus\", onFocus);\n    setTimeout(() => {\n      el.removeEventListener(\"focus\", onFocus);\n    }, 1);\n  });\n}\n\nexport function getStackTrace(): string {\n  try {\n    throw new Error(\"_\");\n  } catch (err) {\n    return err.stack || \"\";\n  }\n}\n\nfunction inferCurrentScript(): ?HTMLScriptElement {\n  try {\n    const stack = getStackTrace();\n    const stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n    const scriptLocation = stackDetails && stackDetails[1];\n\n    if (!scriptLocation) {\n      return;\n    }\n\n    // $FlowFixMe[method-unbinding]\n    for (const script of Array.prototype.slice\n      .call(document.getElementsByTagName(\"script\"))\n      .reverse()) {\n      if (script.src && script.src === scriptLocation) {\n        return script;\n      }\n    }\n  } catch (err) {\n    // pass\n  }\n}\n\nlet currentScript =\n  // eslint-disable-next-line compat/compat\n  typeof document !== \"undefined\" ? document.currentScript : null;\n\ntype GetCurrentScript = () => HTMLScriptElement;\n\nexport const getCurrentScript: GetCurrentScript = memoize(() => {\n  if (currentScript) {\n    return currentScript;\n  }\n\n  currentScript = inferCurrentScript();\n\n  if (currentScript) {\n    return currentScript;\n  }\n\n  throw new Error(\"Can not determine current script\");\n});\n\nconst currentUID = uniqueID();\n\ntype GetCurrentScriptUID = () => string;\n\nexport const getCurrentScriptUID: GetCurrentScriptUID = memoize(() => {\n  let script;\n\n  try {\n    script = getCurrentScript();\n  } catch (err) {\n    return currentUID;\n  }\n\n  let uid = script.getAttribute(ATTRIBUTES.UID);\n\n  if (uid && typeof uid === \"string\") {\n    return uid;\n  }\n\n  uid = script.getAttribute(`${ATTRIBUTES.UID}-auto`);\n\n  if (uid && typeof uid === \"string\") {\n    return uid;\n  }\n\n  if (script.src) {\n    const { src, dataset } = script;\n    const stringToHash = JSON.stringify({ src, dataset });\n    const hashedString = strHashStr(stringToHash);\n    const hashResult = hashedString.slice(\n      hashedString.length - UID_HASH_LENGTH\n    );\n\n    uid = `uid_${hashResult}`;\n  } else {\n    uid = uniqueID();\n  }\n\n  script.setAttribute(`${ATTRIBUTES.UID}-auto`, uid);\n\n  return uid;\n});\n\ntype SubmitFormOptions = {|\n  url: string,\n  target: string,\n  body?: {| [string]: string | boolean |},\n  method?: string,\n|};\n\nexport function submitForm({\n  url,\n  target,\n  body,\n  method = \"post\",\n}: SubmitFormOptions) {\n  const form = document.createElement(\"form\");\n  form.setAttribute(\"target\", target);\n  form.setAttribute(\"method\", method);\n  form.setAttribute(\"action\", url);\n  form.style.display = \"none\";\n\n  if (body) {\n    for (const key of Object.keys(body)) {\n      const input = document.createElement(\"input\");\n      input.setAttribute(\"name\", key);\n      input.setAttribute(\"value\", body[key]?.toString());\n      form.appendChild(input);\n    }\n  }\n\n  getBody().appendChild(form);\n  form.submit();\n  getBody().removeChild(form);\n}\n","/* @flow */\n\nexport const KEY_CODES = {\n  ENTER: 13,\n  SPACE: 32,\n};\n\nexport const ATTRIBUTES = {\n  UID: \"data-uid\",\n};\n\nexport const UID_HASH_LENGTH = 30;\n\n/* eslint-disable no-control-regex*/\nexport const invalidProtocolRegex: RegExp =\n  /([^\\w]*)(javascript|data|vbscript)/im;\nexport const htmlEntitiesRegex: RegExp = /&#(\\w+)(^\\w|;)?/g;\nexport const htmlCtrlEntityRegex: RegExp = /&(newline|tab);/gi;\nexport const ctrlCharactersRegex: RegExp =\n  /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nexport const urlSchemeRegex: RegExp = /^.+(:|&colon;)/gim;\nexport const relativeFirstCharacters = [\".\", \"/\"];\nexport const BLANK_URL = \"about:blank\";\n/* eslint-enable no-control-regex*/\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { type SameDomainWindowType } from \"@krakenjs/cross-domain-utils/src\";\n\ntype RequestOptionsType = {|\n  url: string,\n  method?: string,\n  headers?: { [key: string]: string },\n  json?: $ReadOnlyArray<mixed> | Object,\n  data?: { [key: string]: string },\n  body?: string,\n  win?: SameDomainWindowType,\n  timeout?: number,\n|};\n\ntype ResponseType = {|\n  status: number,\n  headers: { [string]: string },\n  body: Object,\n|};\n\nconst HEADERS = {\n  CONTENT_TYPE: \"content-type\",\n  ACCEPT: \"accept\",\n};\n\nconst headerBuilders = [];\n\nfunction parseHeaders(rawHeaders: string = \"\"): { [string]: string } {\n  const result = {};\n  for (const line of rawHeaders.trim().split(\"\\n\")) {\n    const [key, ...values] = line.split(\":\");\n    result[key.toLowerCase()] = values.join(\":\").trim();\n  }\n  return result;\n}\n\nexport function request({\n  url,\n  method = \"get\",\n  headers = {},\n  json,\n  data,\n  body,\n  win = window,\n  timeout = 0,\n}: RequestOptionsType): ZalgoPromise<ResponseType> {\n  return new ZalgoPromise((resolve, reject) => {\n    if ((json && data) || (json && body) || (data && json)) {\n      throw new Error(\n        `Only options.json or options.data or options.body should be passed`\n      );\n    }\n\n    const normalizedHeaders = {};\n\n    for (const key of Object.keys(headers)) {\n      normalizedHeaders[key.toLowerCase()] = headers[key];\n    }\n\n    if (json) {\n      normalizedHeaders[HEADERS.CONTENT_TYPE] =\n        normalizedHeaders[HEADERS.CONTENT_TYPE] || \"application/json\";\n    } else if (data || body) {\n      normalizedHeaders[HEADERS.CONTENT_TYPE] =\n        normalizedHeaders[HEADERS.CONTENT_TYPE] ||\n        \"application/x-www-form-urlencoded; charset=utf-8\";\n    }\n\n    normalizedHeaders[HEADERS.ACCEPT] =\n      normalizedHeaders[HEADERS.ACCEPT] || \"application/json\";\n\n    for (const headerBuilder of headerBuilders) {\n      const builtHeaders = headerBuilder();\n\n      for (const key of Object.keys(builtHeaders)) {\n        normalizedHeaders[key.toLowerCase()] = builtHeaders[key];\n      }\n    }\n\n    const xhr = new win.XMLHttpRequest();\n\n    xhr.addEventListener(\n      \"load\",\n      function xhrLoad(): void {\n        const responseHeaders = parseHeaders(this.getAllResponseHeaders());\n\n        if (!this.status) {\n          return reject(\n            new Error(\n              `Request to ${method.toLowerCase()} ${url} failed: no response status code.`\n            )\n          );\n        }\n\n        const contentType = responseHeaders[\"content-type\"];\n        const isJSON =\n          contentType &&\n          (contentType.indexOf(\"application/json\") === 0 ||\n            contentType.indexOf(\"text/json\") === 0);\n        let responseBody = this.responseText;\n\n        try {\n          responseBody = JSON.parse(responseBody);\n        } catch (err) {\n          if (isJSON) {\n            return reject(new Error(`Invalid json: ${this.responseText}.`));\n          }\n        }\n\n        const res = {\n          status: this.status,\n          headers: responseHeaders,\n          body: responseBody,\n        };\n\n        return resolve(res);\n      },\n      false\n    );\n\n    xhr.addEventListener(\n      \"error\",\n      (evt) => {\n        reject(\n          new Error(\n            `Request to ${method.toLowerCase()} ${url} failed: ${evt.toString()}.`\n          )\n        );\n      },\n      false\n    );\n\n    xhr.open(method, url, true);\n\n    for (const key in normalizedHeaders) {\n      if (normalizedHeaders.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, normalizedHeaders[key]);\n      }\n    }\n\n    if (json) {\n      body = JSON.stringify(json);\n    } else if (data) {\n      body = Object.keys(data)\n        .map((key) => {\n          return `${encodeURIComponent(key)}=${\n            data ? encodeURIComponent(data[key]) : \"\"\n          }`;\n        })\n        .join(\"&\");\n    }\n\n    xhr.timeout = timeout;\n    xhr.ontimeout = function xhrTimeout() {\n      reject(\n        new Error(`Request to ${method.toLowerCase()} ${url} has timed out`)\n      );\n    };\n\n    xhr.send(body);\n  });\n}\n\nexport function addHeaderBuilder(method: () => { [string]: string }) {\n  headerBuilders.push(method);\n}\n","/* @flow */\n\nexport const LOG_LEVEL = {\n  DEBUG: (\"debug\": \"debug\"),\n  INFO: (\"info\": \"info\"),\n  WARN: (\"warn\": \"warn\"),\n  ERROR: (\"error\": \"error\"),\n};\n\nexport const PROTOCOL = {\n  FILE: \"file:\",\n};\n","/* @flow */\n\nimport { LOG_LEVEL } from \"./constants\";\n\nexport const AUTO_FLUSH_LEVEL = [LOG_LEVEL.WARN, LOG_LEVEL.ERROR];\n\nexport const LOG_LEVEL_PRIORITY = [\n  LOG_LEVEL.ERROR,\n  LOG_LEVEL.WARN,\n  LOG_LEVEL.INFO,\n  LOG_LEVEL.DEBUG,\n];\n\nexport const FLUSH_INTERVAL = 60 * 1000;\n\nexport const DEFAULT_LOG_LEVEL: $Values<typeof LOG_LEVEL> = __DEBUG__\n  ? LOG_LEVEL.DEBUG\n  : LOG_LEVEL.WARN;\n","/* @flow */\n\nimport { type SameDomainWindowType } from \"@krakenjs/cross-domain-utils/src\";\n\nimport type { Payload } from \"./types\";\n\ntype CanUseBeaconOptions = {|\n  headers: { [string]: string },\n  enableSendBeacon: boolean,\n|};\n\nconst canUseSendBeacon = ({\n  headers,\n  enableSendBeacon,\n}: CanUseBeaconOptions): boolean => {\n  const hasHeaders = headers && Object.keys(headers).length;\n  if (\n    window &&\n    window.navigator.sendBeacon &&\n    !hasHeaders &&\n    enableSendBeacon &&\n    window.Blob\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\ntype SendBeaconOptions = {|\n  win: SameDomainWindowType,\n  url: string,\n  data: JSON,\n  useBlob: boolean,\n|};\n\nconst sendBeacon = ({\n  win = window,\n  url,\n  data,\n  useBlob = true,\n}: SendBeaconOptions): boolean => {\n  try {\n    const json = JSON.stringify(data);\n\n    if (!win.navigator.sendBeacon) {\n      throw new Error(`No sendBeacon available`);\n    }\n\n    if (useBlob) {\n      const blob = new Blob([json], { type: \"application/json\" });\n      return win.navigator.sendBeacon(url, blob);\n    }\n\n    return win.navigator.sendBeacon(url, json);\n  } catch (e) {\n    return false;\n  }\n};\n\nconst extendIfDefined = (target: Payload, source: Payload) => {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n};\n\nexport { canUseSendBeacon, extendIfDefined, sendBeacon };\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport { request, noop } from \"@krakenjs/belter/src\";\nimport {\n  isSameDomain,\n  assertSameDomain,\n  type CrossDomainWindowType,\n} from \"@krakenjs/cross-domain-utils/src\";\n\nimport { canUseSendBeacon, sendBeacon } from \"./util\";\n\nexport type TransportOptions = {|\n  url: string,\n  method: string,\n  headers: { [string]: string },\n  json: Object,\n  enableSendBeacon?: boolean,\n|};\n\nexport type Transport = (TransportOptions) => ZalgoPromise<void>;\n\nexport function getHTTPTransport(httpWin?: CrossDomainWindowType): Transport {\n  return ({\n    url,\n    method,\n    headers,\n    json,\n    enableSendBeacon = false,\n  }: TransportOptions): ZalgoPromise<void> => {\n    return ZalgoPromise.try(() => {\n      const httpWindow = httpWin ? httpWin : window;\n      const win = isSameDomain(httpWindow)\n        ? assertSameDomain(httpWindow)\n        : window;\n      let beaconResult = false;\n\n      if (canUseSendBeacon({ headers, enableSendBeacon })) {\n        beaconResult = sendBeacon({ win, url, data: json, useBlob: true });\n      }\n\n      return beaconResult\n        ? beaconResult\n        : request({ win, url, method, headers, json });\n    }).then(noop);\n  };\n}\n","/* @flow */\n\nimport { ZalgoPromise } from \"@krakenjs/zalgo-promise/src\";\nimport {\n  isBrowser,\n  promiseDebounce,\n  noop,\n  safeInterval,\n  objFilter,\n} from \"@krakenjs/belter/src\";\n\nimport {\n  DEFAULT_LOG_LEVEL,\n  LOG_LEVEL_PRIORITY,\n  AUTO_FLUSH_LEVEL,\n  FLUSH_INTERVAL,\n} from \"./config\";\nimport { LOG_LEVEL, PROTOCOL } from \"./constants\";\nimport { extendIfDefined } from \"./util\";\nimport { type Transport, getHTTPTransport } from \"./http\";\nimport type {\n  MetricPayload,\n  Payload,\n  MetricPayloadCounter,\n  MetricPayloadGauge,\n  MetricPayloadHistogram,\n} from \"./types\";\n\nexport type LoggerOptions = {|\n  url?: string,\n  prefix?: string,\n  metricNamespacePrefix?: string,\n  logLevel?: $Values<typeof LOG_LEVEL>,\n  transport?: Transport,\n  flushInterval?: number,\n  enableSendBeacon?: boolean,\n|};\n\ntype ClientPayload = Payload;\ntype Log = (name: string, payload?: ClientPayload) => LoggerType; // eslint-disable-line no-use-before-define\ntype Track = (payload: ClientPayload) => LoggerType; // eslint-disable-line no-use-before-define\ntype LogMetric = (payload: MetricPayload) => LoggerType; // eslint-disable-line no-use-before-define\ntype LogEvent = {|\n  level: $Values<typeof LOG_LEVEL>,\n  event: string,\n  payload: Payload,\n|};\n\ntype Builder = (Payload) => ClientPayload;\ntype AddBuilder = (Builder) => LoggerType; // eslint-disable-line no-use-before-define\n\nexport type LoggerType = {|\n  debug: Log,\n  info: Log,\n  warn: Log,\n  error: Log,\n\n  track: Track,\n  metric: LogMetric,\n  metricCounter: (payload: MetricPayloadCounter) => LoggerType,\n  metricGauge: (payload: MetricPayloadGauge) => LoggerType,\n  metricHistogram: (payload: MetricPayloadHistogram) => LoggerType,\n\n  flush: () => ZalgoPromise<void>,\n  immediateFlush: () => ZalgoPromise<void>,\n\n  addPayloadBuilder: AddBuilder,\n  addMetaBuilder: AddBuilder,\n  addTrackingBuilder: AddBuilder,\n  addMetricDimensionBuilder: AddBuilder,\n  addHeaderBuilder: AddBuilder,\n\n  setTransport: (Transport) => LoggerType,\n  configure: (LoggerOptions) => LoggerType,\n\n  __buffer__: {|\n    get events(): $ReadOnlyArray<LogEvent>,\n    get tracking(): $ReadOnlyArray<Payload>,\n    get metrics(): $ReadOnlyArray<MetricPayload>,\n  |},\n|};\n\nexport function Logger({\n  url,\n  prefix,\n  metricNamespacePrefix,\n  logLevel = DEFAULT_LOG_LEVEL,\n  transport = getHTTPTransport(),\n  flushInterval = FLUSH_INTERVAL,\n  enableSendBeacon = false,\n}: LoggerOptions): LoggerType {\n  let events: Array<LogEvent> = [];\n  let tracking: Array<Payload> = [];\n  let metrics: Array<MetricPayload> = [];\n\n  const payloadBuilders: Array<Builder> = [];\n  const metaBuilders: Array<Builder> = [];\n  const trackingBuilders: Array<Builder> = [];\n  const metricDimensionBuilders: Array<Builder> = [];\n  const headerBuilders: Array<Builder> = [];\n\n  function print(\n    level: $Values<typeof LOG_LEVEL>,\n    event: string,\n    payload: Payload\n  ) {\n    if (!isBrowser() || !window.console || !window.console.log) {\n      return;\n    }\n\n    if (\n      LOG_LEVEL_PRIORITY.indexOf(level) > LOG_LEVEL_PRIORITY.indexOf(logLevel)\n    ) {\n      return;\n    }\n\n    const args = [event];\n\n    args.push(payload);\n\n    if (payload.error || payload.warning) {\n      args.push(\"\\n\\n\", payload.error || payload.warning);\n    }\n\n    try {\n      if (window.console[level] && window.console[level].apply) {\n        window.console[level].apply(window.console, args);\n      } else if (window.console.log && window.console.log.apply) {\n        window.console.log.apply(window.console, args);\n      }\n    } catch (err) {\n      // pass\n    }\n  }\n\n  function immediateFlush(): ZalgoPromise<void> {\n    return ZalgoPromise.try(() => {\n      if (!isBrowser() || window.location.protocol === PROTOCOL.FILE) {\n        return;\n      }\n\n      if (!events.length && !tracking.length && !metrics.length) {\n        return;\n      }\n\n      const meta = {};\n      for (const builder of metaBuilders) {\n        extendIfDefined(meta, builder(meta));\n      }\n\n      const headers = {};\n      for (const builder of headerBuilders) {\n        extendIfDefined(headers, builder(headers));\n      }\n\n      let res;\n\n      if (url) {\n        res = transport({\n          method: \"POST\",\n          url,\n          headers,\n          json: {\n            events,\n            meta,\n            tracking,\n            metrics,\n          },\n          enableSendBeacon,\n        }).catch(noop);\n      }\n\n      events = [];\n      tracking = [];\n      metrics = [];\n\n      return ZalgoPromise.resolve(res).then(noop);\n    });\n  }\n\n  const flush = promiseDebounce(immediateFlush);\n\n  function enqueue(\n    level: $Values<typeof LOG_LEVEL>,\n    event: string,\n    payload: Payload\n  ) {\n    events.push({\n      level,\n      event,\n      payload,\n    });\n\n    if (AUTO_FLUSH_LEVEL.indexOf(level) !== -1) {\n      flush();\n    }\n  }\n\n  function log(\n    level: $Values<typeof LOG_LEVEL>,\n    event: string,\n    payload = {}\n  ): LoggerType {\n    if (!isBrowser()) {\n      return logger; // eslint-disable-line no-use-before-define\n    }\n\n    if (prefix) {\n      event = `${prefix}_${event}`;\n    }\n\n    const logPayload: Payload = {\n      ...objFilter(payload),\n      timestamp: Date.now().toString(),\n    };\n\n    for (const builder of payloadBuilders) {\n      extendIfDefined(logPayload, builder(logPayload));\n    }\n\n    enqueue(level, event, logPayload);\n    print(level, event, logPayload);\n\n    return logger; // eslint-disable-line no-use-before-define\n  }\n\n  function addBuilder(builders, builder): LoggerType {\n    builders.push(builder);\n    return logger; // eslint-disable-line no-use-before-define\n  }\n\n  function addPayloadBuilder(builder): LoggerType {\n    return addBuilder(payloadBuilders, builder);\n  }\n\n  function addMetaBuilder(builder): LoggerType {\n    return addBuilder(metaBuilders, builder);\n  }\n\n  function addTrackingBuilder(builder): LoggerType {\n    return addBuilder(trackingBuilders, builder);\n  }\n\n  function addMetricDimensionBuilder(builder): LoggerType {\n    return addBuilder(metricDimensionBuilders, builder);\n  }\n\n  function addHeaderBuilder(builder): LoggerType {\n    return addBuilder(headerBuilders, builder);\n  }\n\n  function debug(event, payload): LoggerType {\n    return log(LOG_LEVEL.DEBUG, event, payload);\n  }\n\n  function info(event, payload): LoggerType {\n    return log(LOG_LEVEL.INFO, event, payload);\n  }\n\n  function warn(event, payload): LoggerType {\n    return log(LOG_LEVEL.WARN, event, payload);\n  }\n\n  function error(event, payload): LoggerType {\n    return log(LOG_LEVEL.ERROR, event, payload);\n  }\n\n  function track(payload = {}): LoggerType {\n    if (!isBrowser()) {\n      return logger; // eslint-disable-line no-use-before-define\n    }\n\n    const trackingPayload: Payload = objFilter(payload);\n\n    for (const builder of trackingBuilders) {\n      extendIfDefined(trackingPayload, builder(trackingPayload));\n    }\n\n    print(LOG_LEVEL.DEBUG, \"track\", trackingPayload);\n    tracking.push(trackingPayload);\n\n    return logger; // eslint-disable-line no-use-before-define\n  }\n\n  function metric(metricPayload: MetricPayload): LoggerType {\n    if (!isBrowser()) {\n      return logger; // eslint-disable-line no-use-before-define\n    }\n\n    if (metricNamespacePrefix) {\n      metricPayload.metricNamespace = `${metricNamespacePrefix}.${metricPayload.metricNamespace}`;\n    }\n\n    if (metricDimensionBuilders.length > 0 && !metricPayload.dimensions) {\n      metricPayload.dimensions = {};\n    }\n\n    for (const builder of metricDimensionBuilders) {\n      extendIfDefined(\n        metricPayload.dimensions || {},\n        builder(metricPayload.dimensions || {})\n      );\n    }\n\n    print(\n      LOG_LEVEL.DEBUG,\n      `metric.${metricPayload.metricNamespace}`,\n      metricPayload.dimensions || {}\n    );\n\n    metrics.push(metricPayload);\n\n    return logger; // eslint-disable-line no-use-before-define\n  }\n\n  function metricCounter(metricPayload: MetricPayloadCounter): LoggerType {\n    return metric({\n      metricNamespace: metricPayload.namespace,\n      metricEventName: metricPayload.event,\n      metricValue: metricPayload.value ?? 1,\n      metricType: \"counter\",\n      dimensions: metricPayload.dimensions,\n    });\n  }\n\n  function metricGauge(metricPayload: MetricPayloadGauge): LoggerType {\n    return metric({\n      metricNamespace: metricPayload.namespace,\n      metricEventName: metricPayload.event,\n      metricValue: metricPayload.value,\n      metricType: \"gauge\",\n      dimensions: metricPayload.dimensions,\n    });\n  }\n\n  function metricHistogram(metricPayload: MetricPayloadHistogram): LoggerType {\n    return metric({\n      metricNamespace: metricPayload.namespace,\n      metricEventName: metricPayload.event,\n      metricValue: metricPayload.value,\n      metricType: \"histogram\",\n      dimensions: metricPayload.dimensions,\n    });\n  }\n\n  function setTransport(newTransport: Transport): LoggerType {\n    transport = newTransport;\n    return logger; // eslint-disable-line no-use-before-define\n  }\n\n  function configure(opts: LoggerOptions): LoggerType {\n    if (opts.url) {\n      url = opts.url;\n    }\n\n    if (opts.prefix) {\n      prefix = opts.prefix;\n    }\n\n    if (opts.logLevel) {\n      logLevel = opts.logLevel;\n    }\n\n    if (opts.transport) {\n      transport = opts.transport;\n    }\n\n    if (opts.flushInterval) {\n      flushInterval = opts.flushInterval;\n    }\n\n    if (opts.enableSendBeacon) {\n      enableSendBeacon = opts.enableSendBeacon;\n    }\n\n    return logger; // eslint-disable-line no-use-before-define\n  }\n\n  if (isBrowser()) {\n    safeInterval(flush, flushInterval);\n  }\n\n  if (typeof window === \"object\") {\n    window.addEventListener(\"beforeunload\", () => {\n      immediateFlush();\n    });\n\n    window.addEventListener(\"unload\", () => {\n      immediateFlush();\n    });\n\n    window.addEventListener(\"pagehide\", () => {\n      immediateFlush();\n    });\n  }\n\n  const logger = {\n    debug,\n    info,\n    warn,\n    error,\n    track,\n    metric,\n    metricCounter,\n    metricGauge,\n    metricHistogram,\n    flush,\n    immediateFlush,\n    addPayloadBuilder,\n    addMetaBuilder,\n    addMetricDimensionBuilder,\n    addTrackingBuilder,\n    addHeaderBuilder,\n    setTransport,\n    configure,\n\n    // exposed primarily for testing\n    // exposes these buffers as readonly getters only\n    __buffer__: {\n      get events(): $ReadOnlyArray<LogEvent> {\n        return events;\n      },\n      get tracking(): $ReadOnlyArray<Payload> {\n        return tracking;\n      },\n      get metrics(): $ReadOnlyArray<MetricPayload> {\n        return metrics;\n      },\n    },\n  };\n\n  // mark the __buffer__ prop as readonly\n  Object.defineProperty(logger, \"__buffer__\", { writable: false });\n\n  return logger;\n}\n"],"sourceRoot":""}